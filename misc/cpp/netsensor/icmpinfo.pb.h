// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: icmpinfo.proto

#ifndef PROTOBUF_INCLUDED_icmpinfo_2eproto
#define PROTOBUF_INCLUDED_icmpinfo_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_icmpinfo_2eproto 

namespace protobuf_icmpinfo_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[8];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_icmpinfo_2eproto
namespace netsensor {
class ICMPPacketsByInterface;
class ICMPPacketsByInterfaceDefaultTypeInternal;
extern ICMPPacketsByInterfaceDefaultTypeInternal _ICMPPacketsByInterface_default_instance_;
class ProtoData;
class ProtoDataDefaultTypeInternal;
extern ProtoDataDefaultTypeInternal _ProtoData_default_instance_;
class ProtoDatagramInfo;
class ProtoDatagramInfoDefaultTypeInternal;
extern ProtoDatagramInfoDefaultTypeInternal _ProtoDatagramInfo_default_instance_;
class ProtoExtraAddresses;
class ProtoExtraAddressesDefaultTypeInternal;
extern ProtoExtraAddressesDefaultTypeInternal _ProtoExtraAddresses_default_instance_;
class ProtoICMPInfoContainer;
class ProtoICMPInfoContainerDefaultTypeInternal;
extern ProtoICMPInfoContainerDefaultTypeInternal _ProtoICMPInfoContainer_default_instance_;
class ProtoICMPTime;
class ProtoICMPTimeDefaultTypeInternal;
extern ProtoICMPTimeDefaultTypeInternal _ProtoICMPTime_default_instance_;
class ProtoIdentification;
class ProtoIdentificationDefaultTypeInternal;
extern ProtoIdentificationDefaultTypeInternal _ProtoIdentification_default_instance_;
class ProtoIpHeader;
class ProtoIpHeaderDefaultTypeInternal;
extern ProtoIpHeaderDefaultTypeInternal _ProtoIpHeader_default_instance_;
}  // namespace netsensor
namespace google {
namespace protobuf {
template<> ::netsensor::ICMPPacketsByInterface* Arena::CreateMaybeMessage<::netsensor::ICMPPacketsByInterface>(Arena*);
template<> ::netsensor::ProtoData* Arena::CreateMaybeMessage<::netsensor::ProtoData>(Arena*);
template<> ::netsensor::ProtoDatagramInfo* Arena::CreateMaybeMessage<::netsensor::ProtoDatagramInfo>(Arena*);
template<> ::netsensor::ProtoExtraAddresses* Arena::CreateMaybeMessage<::netsensor::ProtoExtraAddresses>(Arena*);
template<> ::netsensor::ProtoICMPInfoContainer* Arena::CreateMaybeMessage<::netsensor::ProtoICMPInfoContainer>(Arena*);
template<> ::netsensor::ProtoICMPTime* Arena::CreateMaybeMessage<::netsensor::ProtoICMPTime>(Arena*);
template<> ::netsensor::ProtoIdentification* Arena::CreateMaybeMessage<::netsensor::ProtoIdentification>(Arena*);
template<> ::netsensor::ProtoIpHeader* Arena::CreateMaybeMessage<::netsensor::ProtoIpHeader>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace netsensor {

// ===================================================================

class ICMPPacketsByInterface : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netsensor.ICMPPacketsByInterface) */ {
 public:
  ICMPPacketsByInterface();
  virtual ~ICMPPacketsByInterface();

  ICMPPacketsByInterface(const ICMPPacketsByInterface& from);

  inline ICMPPacketsByInterface& operator=(const ICMPPacketsByInterface& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ICMPPacketsByInterface(ICMPPacketsByInterface&& from) noexcept
    : ICMPPacketsByInterface() {
    *this = ::std::move(from);
  }

  inline ICMPPacketsByInterface& operator=(ICMPPacketsByInterface&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ICMPPacketsByInterface& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ICMPPacketsByInterface* internal_default_instance() {
    return reinterpret_cast<const ICMPPacketsByInterface*>(
               &_ICMPPacketsByInterface_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(ICMPPacketsByInterface* other);
  friend void swap(ICMPPacketsByInterface& a, ICMPPacketsByInterface& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ICMPPacketsByInterface* New() const final {
    return CreateMaybeMessage<ICMPPacketsByInterface>(NULL);
  }

  ICMPPacketsByInterface* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ICMPPacketsByInterface>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ICMPPacketsByInterface& from);
  void MergeFrom(const ICMPPacketsByInterface& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ICMPPacketsByInterface* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .netsensor.ProtoICMPInfoContainer icmpContainers = 2;
  int icmpcontainers_size() const;
  void clear_icmpcontainers();
  static const int kIcmpContainersFieldNumber = 2;
  ::netsensor::ProtoICMPInfoContainer* mutable_icmpcontainers(int index);
  ::google::protobuf::RepeatedPtrField< ::netsensor::ProtoICMPInfoContainer >*
      mutable_icmpcontainers();
  const ::netsensor::ProtoICMPInfoContainer& icmpcontainers(int index) const;
  ::netsensor::ProtoICMPInfoContainer* add_icmpcontainers();
  const ::google::protobuf::RepeatedPtrField< ::netsensor::ProtoICMPInfoContainer >&
      icmpcontainers() const;

  // string monitoringInterface = 1;
  void clear_monitoringinterface();
  static const int kMonitoringInterfaceFieldNumber = 1;
  const ::std::string& monitoringinterface() const;
  void set_monitoringinterface(const ::std::string& value);
  #if LANG_CXX11
  void set_monitoringinterface(::std::string&& value);
  #endif
  void set_monitoringinterface(const char* value);
  void set_monitoringinterface(const char* value, size_t size);
  ::std::string* mutable_monitoringinterface();
  ::std::string* release_monitoringinterface();
  void set_allocated_monitoringinterface(::std::string* monitoringinterface);

  // @@protoc_insertion_point(class_scope:netsensor.ICMPPacketsByInterface)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::netsensor::ProtoICMPInfoContainer > icmpcontainers_;
  ::google::protobuf::internal::ArenaStringPtr monitoringinterface_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_icmpinfo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProtoICMPInfoContainer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netsensor.ProtoICMPInfoContainer) */ {
 public:
  ProtoICMPInfoContainer();
  virtual ~ProtoICMPInfoContainer();

  ProtoICMPInfoContainer(const ProtoICMPInfoContainer& from);

  inline ProtoICMPInfoContainer& operator=(const ProtoICMPInfoContainer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoICMPInfoContainer(ProtoICMPInfoContainer&& from) noexcept
    : ProtoICMPInfoContainer() {
    *this = ::std::move(from);
  }

  inline ProtoICMPInfoContainer& operator=(ProtoICMPInfoContainer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoICMPInfoContainer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoICMPInfoContainer* internal_default_instance() {
    return reinterpret_cast<const ProtoICMPInfoContainer*>(
               &_ProtoICMPInfoContainer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(ProtoICMPInfoContainer* other);
  friend void swap(ProtoICMPInfoContainer& a, ProtoICMPInfoContainer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoICMPInfoContainer* New() const final {
    return CreateMaybeMessage<ProtoICMPInfoContainer>(NULL);
  }

  ProtoICMPInfoContainer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProtoICMPInfoContainer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProtoICMPInfoContainer& from);
  void MergeFrom(const ProtoICMPInfoContainer& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtoICMPInfoContainer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string sourceMAC = 1;
  void clear_sourcemac();
  static const int kSourceMACFieldNumber = 1;
  const ::std::string& sourcemac() const;
  void set_sourcemac(const ::std::string& value);
  #if LANG_CXX11
  void set_sourcemac(::std::string&& value);
  #endif
  void set_sourcemac(const char* value);
  void set_sourcemac(const char* value, size_t size);
  ::std::string* mutable_sourcemac();
  ::std::string* release_sourcemac();
  void set_allocated_sourcemac(::std::string* sourcemac);

  // string destMAC = 2;
  void clear_destmac();
  static const int kDestMACFieldNumber = 2;
  const ::std::string& destmac() const;
  void set_destmac(const ::std::string& value);
  #if LANG_CXX11
  void set_destmac(::std::string&& value);
  #endif
  void set_destmac(const char* value);
  void set_destmac(const char* value, size_t size);
  ::std::string* mutable_destmac();
  ::std::string* release_destmac();
  void set_allocated_destmac(::std::string* destmac);

  // string sourceIPAddr = 3;
  void clear_sourceipaddr();
  static const int kSourceIPAddrFieldNumber = 3;
  const ::std::string& sourceipaddr() const;
  void set_sourceipaddr(const ::std::string& value);
  #if LANG_CXX11
  void set_sourceipaddr(::std::string&& value);
  #endif
  void set_sourceipaddr(const char* value);
  void set_sourceipaddr(const char* value, size_t size);
  ::std::string* mutable_sourceipaddr();
  ::std::string* release_sourceipaddr();
  void set_allocated_sourceipaddr(::std::string* sourceipaddr);

  // string destIPAddr = 4;
  void clear_destipaddr();
  static const int kDestIPAddrFieldNumber = 4;
  const ::std::string& destipaddr() const;
  void set_destipaddr(const ::std::string& value);
  #if LANG_CXX11
  void set_destipaddr(::std::string&& value);
  #endif
  void set_destipaddr(const char* value);
  void set_destipaddr(const char* value, size_t size);
  ::std::string* mutable_destipaddr();
  ::std::string* release_destipaddr();
  void set_allocated_destipaddr(::std::string* destipaddr);

  // .netsensor.ProtoData ICMPPayload = 8;
  bool has_icmppayload() const;
  void clear_icmppayload();
  static const int kICMPPayloadFieldNumber = 8;
  private:
  const ::netsensor::ProtoData& _internal_icmppayload() const;
  public:
  const ::netsensor::ProtoData& icmppayload() const;
  ::netsensor::ProtoData* release_icmppayload();
  ::netsensor::ProtoData* mutable_icmppayload();
  void set_allocated_icmppayload(::netsensor::ProtoData* icmppayload);

  // .google.protobuf.Timestamp timestamp = 9;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 9;
  private:
  const ::google::protobuf::Timestamp& _internal_timestamp() const;
  public:
  const ::google::protobuf::Timestamp& timestamp() const;
  ::google::protobuf::Timestamp* release_timestamp();
  ::google::protobuf::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::google::protobuf::Timestamp* timestamp);

  // uint32 type = 5;
  void clear_type();
  static const int kTypeFieldNumber = 5;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // uint32 code = 6;
  void clear_code();
  static const int kCodeFieldNumber = 6;
  ::google::protobuf::uint32 code() const;
  void set_code(::google::protobuf::uint32 value);

  // uint32 count = 7;
  void clear_count();
  static const int kCountFieldNumber = 7;
  ::google::protobuf::uint32 count() const;
  void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:netsensor.ProtoICMPInfoContainer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr sourcemac_;
  ::google::protobuf::internal::ArenaStringPtr destmac_;
  ::google::protobuf::internal::ArenaStringPtr sourceipaddr_;
  ::google::protobuf::internal::ArenaStringPtr destipaddr_;
  ::netsensor::ProtoData* icmppayload_;
  ::google::protobuf::Timestamp* timestamp_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 code_;
  ::google::protobuf::uint32 count_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_icmpinfo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProtoData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netsensor.ProtoData) */ {
 public:
  ProtoData();
  virtual ~ProtoData();

  ProtoData(const ProtoData& from);

  inline ProtoData& operator=(const ProtoData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoData(ProtoData&& from) noexcept
    : ProtoData() {
    *this = ::std::move(from);
  }

  inline ProtoData& operator=(ProtoData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoData* internal_default_instance() {
    return reinterpret_cast<const ProtoData*>(
               &_ProtoData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(ProtoData* other);
  friend void swap(ProtoData& a, ProtoData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoData* New() const final {
    return CreateMaybeMessage<ProtoData>(NULL);
  }

  ProtoData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProtoData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProtoData& from);
  void MergeFrom(const ProtoData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtoData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .netsensor.ProtoExtraAddresses extraAddresses = 6;
  int extraaddresses_size() const;
  void clear_extraaddresses();
  static const int kExtraAddressesFieldNumber = 6;
  ::netsensor::ProtoExtraAddresses* mutable_extraaddresses(int index);
  ::google::protobuf::RepeatedPtrField< ::netsensor::ProtoExtraAddresses >*
      mutable_extraaddresses();
  const ::netsensor::ProtoExtraAddresses& extraaddresses(int index) const;
  ::netsensor::ProtoExtraAddresses* add_extraaddresses();
  const ::google::protobuf::RepeatedPtrField< ::netsensor::ProtoExtraAddresses >&
      extraaddresses() const;

  // .netsensor.ProtoIdentification id = 2;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 2;
  private:
  const ::netsensor::ProtoIdentification& _internal_id() const;
  public:
  const ::netsensor::ProtoIdentification& id() const;
  ::netsensor::ProtoIdentification* release_id();
  ::netsensor::ProtoIdentification* mutable_id();
  void set_allocated_id(::netsensor::ProtoIdentification* id);

  // .netsensor.ProtoIpHeader ipHeader = 3;
  bool has_ipheader() const;
  void clear_ipheader();
  static const int kIpHeaderFieldNumber = 3;
  private:
  const ::netsensor::ProtoIpHeader& _internal_ipheader() const;
  public:
  const ::netsensor::ProtoIpHeader& ipheader() const;
  ::netsensor::ProtoIpHeader* release_ipheader();
  ::netsensor::ProtoIpHeader* mutable_ipheader();
  void set_allocated_ipheader(::netsensor::ProtoIpHeader* ipheader);

  // .netsensor.ProtoDatagramInfo dgram = 4;
  bool has_dgram() const;
  void clear_dgram();
  static const int kDgramFieldNumber = 4;
  private:
  const ::netsensor::ProtoDatagramInfo& _internal_dgram() const;
  public:
  const ::netsensor::ProtoDatagramInfo& dgram() const;
  ::netsensor::ProtoDatagramInfo* release_dgram();
  ::netsensor::ProtoDatagramInfo* mutable_dgram();
  void set_allocated_dgram(::netsensor::ProtoDatagramInfo* dgram);

  // .netsensor.ProtoICMPTime icmpTimestamp = 5;
  bool has_icmptimestamp() const;
  void clear_icmptimestamp();
  static const int kIcmpTimestampFieldNumber = 5;
  private:
  const ::netsensor::ProtoICMPTime& _internal_icmptimestamp() const;
  public:
  const ::netsensor::ProtoICMPTime& icmptimestamp() const;
  ::netsensor::ProtoICMPTime* release_icmptimestamp();
  ::netsensor::ProtoICMPTime* mutable_icmptimestamp();
  void set_allocated_icmptimestamp(::netsensor::ProtoICMPTime* icmptimestamp);

  // uint32 pointerToError = 1;
  void clear_pointertoerror();
  static const int kPointerToErrorFieldNumber = 1;
  ::google::protobuf::uint32 pointertoerror() const;
  void set_pointertoerror(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:netsensor.ProtoData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::netsensor::ProtoExtraAddresses > extraaddresses_;
  ::netsensor::ProtoIdentification* id_;
  ::netsensor::ProtoIpHeader* ipheader_;
  ::netsensor::ProtoDatagramInfo* dgram_;
  ::netsensor::ProtoICMPTime* icmptimestamp_;
  ::google::protobuf::uint32 pointertoerror_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_icmpinfo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProtoIdentification : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netsensor.ProtoIdentification) */ {
 public:
  ProtoIdentification();
  virtual ~ProtoIdentification();

  ProtoIdentification(const ProtoIdentification& from);

  inline ProtoIdentification& operator=(const ProtoIdentification& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoIdentification(ProtoIdentification&& from) noexcept
    : ProtoIdentification() {
    *this = ::std::move(from);
  }

  inline ProtoIdentification& operator=(ProtoIdentification&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoIdentification& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoIdentification* internal_default_instance() {
    return reinterpret_cast<const ProtoIdentification*>(
               &_ProtoIdentification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ProtoIdentification* other);
  friend void swap(ProtoIdentification& a, ProtoIdentification& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoIdentification* New() const final {
    return CreateMaybeMessage<ProtoIdentification>(NULL);
  }

  ProtoIdentification* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProtoIdentification>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProtoIdentification& from);
  void MergeFrom(const ProtoIdentification& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtoIdentification* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 identifier = 1;
  void clear_identifier();
  static const int kIdentifierFieldNumber = 1;
  ::google::protobuf::uint32 identifier() const;
  void set_identifier(::google::protobuf::uint32 value);

  // uint32 sequenceNumber = 2;
  void clear_sequencenumber();
  static const int kSequenceNumberFieldNumber = 2;
  ::google::protobuf::uint32 sequencenumber() const;
  void set_sequencenumber(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:netsensor.ProtoIdentification)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 identifier_;
  ::google::protobuf::uint32 sequencenumber_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_icmpinfo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProtoIpHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netsensor.ProtoIpHeader) */ {
 public:
  ProtoIpHeader();
  virtual ~ProtoIpHeader();

  ProtoIpHeader(const ProtoIpHeader& from);

  inline ProtoIpHeader& operator=(const ProtoIpHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoIpHeader(ProtoIpHeader&& from) noexcept
    : ProtoIpHeader() {
    *this = ::std::move(from);
  }

  inline ProtoIpHeader& operator=(ProtoIpHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoIpHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoIpHeader* internal_default_instance() {
    return reinterpret_cast<const ProtoIpHeader*>(
               &_ProtoIpHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ProtoIpHeader* other);
  friend void swap(ProtoIpHeader& a, ProtoIpHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoIpHeader* New() const final {
    return CreateMaybeMessage<ProtoIpHeader>(NULL);
  }

  ProtoIpHeader* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProtoIpHeader>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProtoIpHeader& from);
  void MergeFrom(const ProtoIpHeader& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtoIpHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string origSourceIPAddr = 4;
  void clear_origsourceipaddr();
  static const int kOrigSourceIPAddrFieldNumber = 4;
  const ::std::string& origsourceipaddr() const;
  void set_origsourceipaddr(const ::std::string& value);
  #if LANG_CXX11
  void set_origsourceipaddr(::std::string&& value);
  #endif
  void set_origsourceipaddr(const char* value);
  void set_origsourceipaddr(const char* value, size_t size);
  ::std::string* mutable_origsourceipaddr();
  ::std::string* release_origsourceipaddr();
  void set_allocated_origsourceipaddr(::std::string* origsourceipaddr);

  // string origDestIPAddr = 5;
  void clear_origdestipaddr();
  static const int kOrigDestIPAddrFieldNumber = 5;
  const ::std::string& origdestipaddr() const;
  void set_origdestipaddr(const ::std::string& value);
  #if LANG_CXX11
  void set_origdestipaddr(::std::string&& value);
  #endif
  void set_origdestipaddr(const char* value);
  void set_origdestipaddr(const char* value, size_t size);
  ::std::string* mutable_origdestipaddr();
  ::std::string* release_origdestipaddr();
  void set_allocated_origdestipaddr(::std::string* origdestipaddr);

  // uint32 tos = 1;
  void clear_tos();
  static const int kTosFieldNumber = 1;
  ::google::protobuf::uint32 tos() const;
  void set_tos(::google::protobuf::uint32 value);

  // uint32 length = 2;
  void clear_length();
  static const int kLengthFieldNumber = 2;
  ::google::protobuf::uint32 length() const;
  void set_length(::google::protobuf::uint32 value);

  // uint32 protocol = 3;
  void clear_protocol();
  static const int kProtocolFieldNumber = 3;
  ::google::protobuf::uint32 protocol() const;
  void set_protocol(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:netsensor.ProtoIpHeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr origsourceipaddr_;
  ::google::protobuf::internal::ArenaStringPtr origdestipaddr_;
  ::google::protobuf::uint32 tos_;
  ::google::protobuf::uint32 length_;
  ::google::protobuf::uint32 protocol_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_icmpinfo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProtoDatagramInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netsensor.ProtoDatagramInfo) */ {
 public:
  ProtoDatagramInfo();
  virtual ~ProtoDatagramInfo();

  ProtoDatagramInfo(const ProtoDatagramInfo& from);

  inline ProtoDatagramInfo& operator=(const ProtoDatagramInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoDatagramInfo(ProtoDatagramInfo&& from) noexcept
    : ProtoDatagramInfo() {
    *this = ::std::move(from);
  }

  inline ProtoDatagramInfo& operator=(ProtoDatagramInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoDatagramInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoDatagramInfo* internal_default_instance() {
    return reinterpret_cast<const ProtoDatagramInfo*>(
               &_ProtoDatagramInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(ProtoDatagramInfo* other);
  friend void swap(ProtoDatagramInfo& a, ProtoDatagramInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoDatagramInfo* New() const final {
    return CreateMaybeMessage<ProtoDatagramInfo>(NULL);
  }

  ProtoDatagramInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProtoDatagramInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProtoDatagramInfo& from);
  void MergeFrom(const ProtoDatagramInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtoDatagramInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 sourcePort = 1;
  void clear_sourceport();
  static const int kSourcePortFieldNumber = 1;
  ::google::protobuf::uint32 sourceport() const;
  void set_sourceport(::google::protobuf::uint32 value);

  // uint32 destPort = 2;
  void clear_destport();
  static const int kDestPortFieldNumber = 2;
  ::google::protobuf::uint32 destport() const;
  void set_destport(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:netsensor.ProtoDatagramInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 sourceport_;
  ::google::protobuf::uint32 destport_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_icmpinfo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProtoICMPTime : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netsensor.ProtoICMPTime) */ {
 public:
  ProtoICMPTime();
  virtual ~ProtoICMPTime();

  ProtoICMPTime(const ProtoICMPTime& from);

  inline ProtoICMPTime& operator=(const ProtoICMPTime& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoICMPTime(ProtoICMPTime&& from) noexcept
    : ProtoICMPTime() {
    *this = ::std::move(from);
  }

  inline ProtoICMPTime& operator=(ProtoICMPTime&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoICMPTime& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoICMPTime* internal_default_instance() {
    return reinterpret_cast<const ProtoICMPTime*>(
               &_ProtoICMPTime_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(ProtoICMPTime* other);
  friend void swap(ProtoICMPTime& a, ProtoICMPTime& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoICMPTime* New() const final {
    return CreateMaybeMessage<ProtoICMPTime>(NULL);
  }

  ProtoICMPTime* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProtoICMPTime>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProtoICMPTime& from);
  void MergeFrom(const ProtoICMPTime& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtoICMPTime* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 originateTimestamp = 1;
  void clear_originatetimestamp();
  static const int kOriginateTimestampFieldNumber = 1;
  ::google::protobuf::uint32 originatetimestamp() const;
  void set_originatetimestamp(::google::protobuf::uint32 value);

  // uint32 receiveTimestamp = 2;
  void clear_receivetimestamp();
  static const int kReceiveTimestampFieldNumber = 2;
  ::google::protobuf::uint32 receivetimestamp() const;
  void set_receivetimestamp(::google::protobuf::uint32 value);

  // uint32 transmitTimestamp = 3;
  void clear_transmittimestamp();
  static const int kTransmitTimestampFieldNumber = 3;
  ::google::protobuf::uint32 transmittimestamp() const;
  void set_transmittimestamp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:netsensor.ProtoICMPTime)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 originatetimestamp_;
  ::google::protobuf::uint32 receivetimestamp_;
  ::google::protobuf::uint32 transmittimestamp_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_icmpinfo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProtoExtraAddresses : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netsensor.ProtoExtraAddresses) */ {
 public:
  ProtoExtraAddresses();
  virtual ~ProtoExtraAddresses();

  ProtoExtraAddresses(const ProtoExtraAddresses& from);

  inline ProtoExtraAddresses& operator=(const ProtoExtraAddresses& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoExtraAddresses(ProtoExtraAddresses&& from) noexcept
    : ProtoExtraAddresses() {
    *this = ::std::move(from);
  }

  inline ProtoExtraAddresses& operator=(ProtoExtraAddresses&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoExtraAddresses& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoExtraAddresses* internal_default_instance() {
    return reinterpret_cast<const ProtoExtraAddresses*>(
               &_ProtoExtraAddresses_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(ProtoExtraAddresses* other);
  friend void swap(ProtoExtraAddresses& a, ProtoExtraAddresses& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoExtraAddresses* New() const final {
    return CreateMaybeMessage<ProtoExtraAddresses>(NULL);
  }

  ProtoExtraAddresses* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProtoExtraAddresses>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProtoExtraAddresses& from);
  void MergeFrom(const ProtoExtraAddresses& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtoExtraAddresses* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string IPAddress = 1;
  void clear_ipaddress();
  static const int kIPAddressFieldNumber = 1;
  const ::std::string& ipaddress() const;
  void set_ipaddress(const ::std::string& value);
  #if LANG_CXX11
  void set_ipaddress(::std::string&& value);
  #endif
  void set_ipaddress(const char* value);
  void set_ipaddress(const char* value, size_t size);
  ::std::string* mutable_ipaddress();
  ::std::string* release_ipaddress();
  void set_allocated_ipaddress(::std::string* ipaddress);

  // uint32 timesRepeated = 2;
  void clear_timesrepeated();
  static const int kTimesRepeatedFieldNumber = 2;
  ::google::protobuf::uint32 timesrepeated() const;
  void set_timesrepeated(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:netsensor.ProtoExtraAddresses)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr ipaddress_;
  ::google::protobuf::uint32 timesrepeated_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_icmpinfo_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ICMPPacketsByInterface

// string monitoringInterface = 1;
inline void ICMPPacketsByInterface::clear_monitoringinterface() {
  monitoringinterface_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ICMPPacketsByInterface::monitoringinterface() const {
  // @@protoc_insertion_point(field_get:netsensor.ICMPPacketsByInterface.monitoringInterface)
  return monitoringinterface_.GetNoArena();
}
inline void ICMPPacketsByInterface::set_monitoringinterface(const ::std::string& value) {
  
  monitoringinterface_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netsensor.ICMPPacketsByInterface.monitoringInterface)
}
#if LANG_CXX11
inline void ICMPPacketsByInterface::set_monitoringinterface(::std::string&& value) {
  
  monitoringinterface_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netsensor.ICMPPacketsByInterface.monitoringInterface)
}
#endif
inline void ICMPPacketsByInterface::set_monitoringinterface(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  monitoringinterface_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netsensor.ICMPPacketsByInterface.monitoringInterface)
}
inline void ICMPPacketsByInterface::set_monitoringinterface(const char* value, size_t size) {
  
  monitoringinterface_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netsensor.ICMPPacketsByInterface.monitoringInterface)
}
inline ::std::string* ICMPPacketsByInterface::mutable_monitoringinterface() {
  
  // @@protoc_insertion_point(field_mutable:netsensor.ICMPPacketsByInterface.monitoringInterface)
  return monitoringinterface_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ICMPPacketsByInterface::release_monitoringinterface() {
  // @@protoc_insertion_point(field_release:netsensor.ICMPPacketsByInterface.monitoringInterface)
  
  return monitoringinterface_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ICMPPacketsByInterface::set_allocated_monitoringinterface(::std::string* monitoringinterface) {
  if (monitoringinterface != NULL) {
    
  } else {
    
  }
  monitoringinterface_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), monitoringinterface);
  // @@protoc_insertion_point(field_set_allocated:netsensor.ICMPPacketsByInterface.monitoringInterface)
}

// repeated .netsensor.ProtoICMPInfoContainer icmpContainers = 2;
inline int ICMPPacketsByInterface::icmpcontainers_size() const {
  return icmpcontainers_.size();
}
inline void ICMPPacketsByInterface::clear_icmpcontainers() {
  icmpcontainers_.Clear();
}
inline ::netsensor::ProtoICMPInfoContainer* ICMPPacketsByInterface::mutable_icmpcontainers(int index) {
  // @@protoc_insertion_point(field_mutable:netsensor.ICMPPacketsByInterface.icmpContainers)
  return icmpcontainers_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::netsensor::ProtoICMPInfoContainer >*
ICMPPacketsByInterface::mutable_icmpcontainers() {
  // @@protoc_insertion_point(field_mutable_list:netsensor.ICMPPacketsByInterface.icmpContainers)
  return &icmpcontainers_;
}
inline const ::netsensor::ProtoICMPInfoContainer& ICMPPacketsByInterface::icmpcontainers(int index) const {
  // @@protoc_insertion_point(field_get:netsensor.ICMPPacketsByInterface.icmpContainers)
  return icmpcontainers_.Get(index);
}
inline ::netsensor::ProtoICMPInfoContainer* ICMPPacketsByInterface::add_icmpcontainers() {
  // @@protoc_insertion_point(field_add:netsensor.ICMPPacketsByInterface.icmpContainers)
  return icmpcontainers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::netsensor::ProtoICMPInfoContainer >&
ICMPPacketsByInterface::icmpcontainers() const {
  // @@protoc_insertion_point(field_list:netsensor.ICMPPacketsByInterface.icmpContainers)
  return icmpcontainers_;
}

// -------------------------------------------------------------------

// ProtoICMPInfoContainer

// string sourceMAC = 1;
inline void ProtoICMPInfoContainer::clear_sourcemac() {
  sourcemac_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ProtoICMPInfoContainer::sourcemac() const {
  // @@protoc_insertion_point(field_get:netsensor.ProtoICMPInfoContainer.sourceMAC)
  return sourcemac_.GetNoArena();
}
inline void ProtoICMPInfoContainer::set_sourcemac(const ::std::string& value) {
  
  sourcemac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netsensor.ProtoICMPInfoContainer.sourceMAC)
}
#if LANG_CXX11
inline void ProtoICMPInfoContainer::set_sourcemac(::std::string&& value) {
  
  sourcemac_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netsensor.ProtoICMPInfoContainer.sourceMAC)
}
#endif
inline void ProtoICMPInfoContainer::set_sourcemac(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sourcemac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netsensor.ProtoICMPInfoContainer.sourceMAC)
}
inline void ProtoICMPInfoContainer::set_sourcemac(const char* value, size_t size) {
  
  sourcemac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netsensor.ProtoICMPInfoContainer.sourceMAC)
}
inline ::std::string* ProtoICMPInfoContainer::mutable_sourcemac() {
  
  // @@protoc_insertion_point(field_mutable:netsensor.ProtoICMPInfoContainer.sourceMAC)
  return sourcemac_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProtoICMPInfoContainer::release_sourcemac() {
  // @@protoc_insertion_point(field_release:netsensor.ProtoICMPInfoContainer.sourceMAC)
  
  return sourcemac_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProtoICMPInfoContainer::set_allocated_sourcemac(::std::string* sourcemac) {
  if (sourcemac != NULL) {
    
  } else {
    
  }
  sourcemac_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sourcemac);
  // @@protoc_insertion_point(field_set_allocated:netsensor.ProtoICMPInfoContainer.sourceMAC)
}

// string destMAC = 2;
inline void ProtoICMPInfoContainer::clear_destmac() {
  destmac_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ProtoICMPInfoContainer::destmac() const {
  // @@protoc_insertion_point(field_get:netsensor.ProtoICMPInfoContainer.destMAC)
  return destmac_.GetNoArena();
}
inline void ProtoICMPInfoContainer::set_destmac(const ::std::string& value) {
  
  destmac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netsensor.ProtoICMPInfoContainer.destMAC)
}
#if LANG_CXX11
inline void ProtoICMPInfoContainer::set_destmac(::std::string&& value) {
  
  destmac_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netsensor.ProtoICMPInfoContainer.destMAC)
}
#endif
inline void ProtoICMPInfoContainer::set_destmac(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  destmac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netsensor.ProtoICMPInfoContainer.destMAC)
}
inline void ProtoICMPInfoContainer::set_destmac(const char* value, size_t size) {
  
  destmac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netsensor.ProtoICMPInfoContainer.destMAC)
}
inline ::std::string* ProtoICMPInfoContainer::mutable_destmac() {
  
  // @@protoc_insertion_point(field_mutable:netsensor.ProtoICMPInfoContainer.destMAC)
  return destmac_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProtoICMPInfoContainer::release_destmac() {
  // @@protoc_insertion_point(field_release:netsensor.ProtoICMPInfoContainer.destMAC)
  
  return destmac_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProtoICMPInfoContainer::set_allocated_destmac(::std::string* destmac) {
  if (destmac != NULL) {
    
  } else {
    
  }
  destmac_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), destmac);
  // @@protoc_insertion_point(field_set_allocated:netsensor.ProtoICMPInfoContainer.destMAC)
}

// string sourceIPAddr = 3;
inline void ProtoICMPInfoContainer::clear_sourceipaddr() {
  sourceipaddr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ProtoICMPInfoContainer::sourceipaddr() const {
  // @@protoc_insertion_point(field_get:netsensor.ProtoICMPInfoContainer.sourceIPAddr)
  return sourceipaddr_.GetNoArena();
}
inline void ProtoICMPInfoContainer::set_sourceipaddr(const ::std::string& value) {
  
  sourceipaddr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netsensor.ProtoICMPInfoContainer.sourceIPAddr)
}
#if LANG_CXX11
inline void ProtoICMPInfoContainer::set_sourceipaddr(::std::string&& value) {
  
  sourceipaddr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netsensor.ProtoICMPInfoContainer.sourceIPAddr)
}
#endif
inline void ProtoICMPInfoContainer::set_sourceipaddr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sourceipaddr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netsensor.ProtoICMPInfoContainer.sourceIPAddr)
}
inline void ProtoICMPInfoContainer::set_sourceipaddr(const char* value, size_t size) {
  
  sourceipaddr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netsensor.ProtoICMPInfoContainer.sourceIPAddr)
}
inline ::std::string* ProtoICMPInfoContainer::mutable_sourceipaddr() {
  
  // @@protoc_insertion_point(field_mutable:netsensor.ProtoICMPInfoContainer.sourceIPAddr)
  return sourceipaddr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProtoICMPInfoContainer::release_sourceipaddr() {
  // @@protoc_insertion_point(field_release:netsensor.ProtoICMPInfoContainer.sourceIPAddr)
  
  return sourceipaddr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProtoICMPInfoContainer::set_allocated_sourceipaddr(::std::string* sourceipaddr) {
  if (sourceipaddr != NULL) {
    
  } else {
    
  }
  sourceipaddr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sourceipaddr);
  // @@protoc_insertion_point(field_set_allocated:netsensor.ProtoICMPInfoContainer.sourceIPAddr)
}

// string destIPAddr = 4;
inline void ProtoICMPInfoContainer::clear_destipaddr() {
  destipaddr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ProtoICMPInfoContainer::destipaddr() const {
  // @@protoc_insertion_point(field_get:netsensor.ProtoICMPInfoContainer.destIPAddr)
  return destipaddr_.GetNoArena();
}
inline void ProtoICMPInfoContainer::set_destipaddr(const ::std::string& value) {
  
  destipaddr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netsensor.ProtoICMPInfoContainer.destIPAddr)
}
#if LANG_CXX11
inline void ProtoICMPInfoContainer::set_destipaddr(::std::string&& value) {
  
  destipaddr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netsensor.ProtoICMPInfoContainer.destIPAddr)
}
#endif
inline void ProtoICMPInfoContainer::set_destipaddr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  destipaddr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netsensor.ProtoICMPInfoContainer.destIPAddr)
}
inline void ProtoICMPInfoContainer::set_destipaddr(const char* value, size_t size) {
  
  destipaddr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netsensor.ProtoICMPInfoContainer.destIPAddr)
}
inline ::std::string* ProtoICMPInfoContainer::mutable_destipaddr() {
  
  // @@protoc_insertion_point(field_mutable:netsensor.ProtoICMPInfoContainer.destIPAddr)
  return destipaddr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProtoICMPInfoContainer::release_destipaddr() {
  // @@protoc_insertion_point(field_release:netsensor.ProtoICMPInfoContainer.destIPAddr)
  
  return destipaddr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProtoICMPInfoContainer::set_allocated_destipaddr(::std::string* destipaddr) {
  if (destipaddr != NULL) {
    
  } else {
    
  }
  destipaddr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), destipaddr);
  // @@protoc_insertion_point(field_set_allocated:netsensor.ProtoICMPInfoContainer.destIPAddr)
}

// uint32 type = 5;
inline void ProtoICMPInfoContainer::clear_type() {
  type_ = 0u;
}
inline ::google::protobuf::uint32 ProtoICMPInfoContainer::type() const {
  // @@protoc_insertion_point(field_get:netsensor.ProtoICMPInfoContainer.type)
  return type_;
}
inline void ProtoICMPInfoContainer::set_type(::google::protobuf::uint32 value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:netsensor.ProtoICMPInfoContainer.type)
}

// uint32 code = 6;
inline void ProtoICMPInfoContainer::clear_code() {
  code_ = 0u;
}
inline ::google::protobuf::uint32 ProtoICMPInfoContainer::code() const {
  // @@protoc_insertion_point(field_get:netsensor.ProtoICMPInfoContainer.code)
  return code_;
}
inline void ProtoICMPInfoContainer::set_code(::google::protobuf::uint32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:netsensor.ProtoICMPInfoContainer.code)
}

// uint32 count = 7;
inline void ProtoICMPInfoContainer::clear_count() {
  count_ = 0u;
}
inline ::google::protobuf::uint32 ProtoICMPInfoContainer::count() const {
  // @@protoc_insertion_point(field_get:netsensor.ProtoICMPInfoContainer.count)
  return count_;
}
inline void ProtoICMPInfoContainer::set_count(::google::protobuf::uint32 value) {
  
  count_ = value;
  // @@protoc_insertion_point(field_set:netsensor.ProtoICMPInfoContainer.count)
}

// .netsensor.ProtoData ICMPPayload = 8;
inline bool ProtoICMPInfoContainer::has_icmppayload() const {
  return this != internal_default_instance() && icmppayload_ != NULL;
}
inline void ProtoICMPInfoContainer::clear_icmppayload() {
  if (GetArenaNoVirtual() == NULL && icmppayload_ != NULL) {
    delete icmppayload_;
  }
  icmppayload_ = NULL;
}
inline const ::netsensor::ProtoData& ProtoICMPInfoContainer::_internal_icmppayload() const {
  return *icmppayload_;
}
inline const ::netsensor::ProtoData& ProtoICMPInfoContainer::icmppayload() const {
  const ::netsensor::ProtoData* p = icmppayload_;
  // @@protoc_insertion_point(field_get:netsensor.ProtoICMPInfoContainer.ICMPPayload)
  return p != NULL ? *p : *reinterpret_cast<const ::netsensor::ProtoData*>(
      &::netsensor::_ProtoData_default_instance_);
}
inline ::netsensor::ProtoData* ProtoICMPInfoContainer::release_icmppayload() {
  // @@protoc_insertion_point(field_release:netsensor.ProtoICMPInfoContainer.ICMPPayload)
  
  ::netsensor::ProtoData* temp = icmppayload_;
  icmppayload_ = NULL;
  return temp;
}
inline ::netsensor::ProtoData* ProtoICMPInfoContainer::mutable_icmppayload() {
  
  if (icmppayload_ == NULL) {
    auto* p = CreateMaybeMessage<::netsensor::ProtoData>(GetArenaNoVirtual());
    icmppayload_ = p;
  }
  // @@protoc_insertion_point(field_mutable:netsensor.ProtoICMPInfoContainer.ICMPPayload)
  return icmppayload_;
}
inline void ProtoICMPInfoContainer::set_allocated_icmppayload(::netsensor::ProtoData* icmppayload) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete icmppayload_;
  }
  if (icmppayload) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      icmppayload = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, icmppayload, submessage_arena);
    }
    
  } else {
    
  }
  icmppayload_ = icmppayload;
  // @@protoc_insertion_point(field_set_allocated:netsensor.ProtoICMPInfoContainer.ICMPPayload)
}

// .google.protobuf.Timestamp timestamp = 9;
inline bool ProtoICMPInfoContainer::has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != NULL;
}
inline const ::google::protobuf::Timestamp& ProtoICMPInfoContainer::_internal_timestamp() const {
  return *timestamp_;
}
inline const ::google::protobuf::Timestamp& ProtoICMPInfoContainer::timestamp() const {
  const ::google::protobuf::Timestamp* p = timestamp_;
  // @@protoc_insertion_point(field_get:netsensor.ProtoICMPInfoContainer.timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* ProtoICMPInfoContainer::release_timestamp() {
  // @@protoc_insertion_point(field_release:netsensor.ProtoICMPInfoContainer.timestamp)
  
  ::google::protobuf::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline ::google::protobuf::Timestamp* ProtoICMPInfoContainer::mutable_timestamp() {
  
  if (timestamp_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    timestamp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:netsensor.ProtoICMPInfoContainer.timestamp)
  return timestamp_;
}
inline void ProtoICMPInfoContainer::set_allocated_timestamp(::google::protobuf::Timestamp* timestamp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(timestamp)->GetArena();
    if (message_arena != submessage_arena) {
      timestamp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:netsensor.ProtoICMPInfoContainer.timestamp)
}

// -------------------------------------------------------------------

// ProtoData

// uint32 pointerToError = 1;
inline void ProtoData::clear_pointertoerror() {
  pointertoerror_ = 0u;
}
inline ::google::protobuf::uint32 ProtoData::pointertoerror() const {
  // @@protoc_insertion_point(field_get:netsensor.ProtoData.pointerToError)
  return pointertoerror_;
}
inline void ProtoData::set_pointertoerror(::google::protobuf::uint32 value) {
  
  pointertoerror_ = value;
  // @@protoc_insertion_point(field_set:netsensor.ProtoData.pointerToError)
}

// .netsensor.ProtoIdentification id = 2;
inline bool ProtoData::has_id() const {
  return this != internal_default_instance() && id_ != NULL;
}
inline void ProtoData::clear_id() {
  if (GetArenaNoVirtual() == NULL && id_ != NULL) {
    delete id_;
  }
  id_ = NULL;
}
inline const ::netsensor::ProtoIdentification& ProtoData::_internal_id() const {
  return *id_;
}
inline const ::netsensor::ProtoIdentification& ProtoData::id() const {
  const ::netsensor::ProtoIdentification* p = id_;
  // @@protoc_insertion_point(field_get:netsensor.ProtoData.id)
  return p != NULL ? *p : *reinterpret_cast<const ::netsensor::ProtoIdentification*>(
      &::netsensor::_ProtoIdentification_default_instance_);
}
inline ::netsensor::ProtoIdentification* ProtoData::release_id() {
  // @@protoc_insertion_point(field_release:netsensor.ProtoData.id)
  
  ::netsensor::ProtoIdentification* temp = id_;
  id_ = NULL;
  return temp;
}
inline ::netsensor::ProtoIdentification* ProtoData::mutable_id() {
  
  if (id_ == NULL) {
    auto* p = CreateMaybeMessage<::netsensor::ProtoIdentification>(GetArenaNoVirtual());
    id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:netsensor.ProtoData.id)
  return id_;
}
inline void ProtoData::set_allocated_id(::netsensor::ProtoIdentification* id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete id_;
  }
  if (id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:netsensor.ProtoData.id)
}

// .netsensor.ProtoIpHeader ipHeader = 3;
inline bool ProtoData::has_ipheader() const {
  return this != internal_default_instance() && ipheader_ != NULL;
}
inline void ProtoData::clear_ipheader() {
  if (GetArenaNoVirtual() == NULL && ipheader_ != NULL) {
    delete ipheader_;
  }
  ipheader_ = NULL;
}
inline const ::netsensor::ProtoIpHeader& ProtoData::_internal_ipheader() const {
  return *ipheader_;
}
inline const ::netsensor::ProtoIpHeader& ProtoData::ipheader() const {
  const ::netsensor::ProtoIpHeader* p = ipheader_;
  // @@protoc_insertion_point(field_get:netsensor.ProtoData.ipHeader)
  return p != NULL ? *p : *reinterpret_cast<const ::netsensor::ProtoIpHeader*>(
      &::netsensor::_ProtoIpHeader_default_instance_);
}
inline ::netsensor::ProtoIpHeader* ProtoData::release_ipheader() {
  // @@protoc_insertion_point(field_release:netsensor.ProtoData.ipHeader)
  
  ::netsensor::ProtoIpHeader* temp = ipheader_;
  ipheader_ = NULL;
  return temp;
}
inline ::netsensor::ProtoIpHeader* ProtoData::mutable_ipheader() {
  
  if (ipheader_ == NULL) {
    auto* p = CreateMaybeMessage<::netsensor::ProtoIpHeader>(GetArenaNoVirtual());
    ipheader_ = p;
  }
  // @@protoc_insertion_point(field_mutable:netsensor.ProtoData.ipHeader)
  return ipheader_;
}
inline void ProtoData::set_allocated_ipheader(::netsensor::ProtoIpHeader* ipheader) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ipheader_;
  }
  if (ipheader) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ipheader = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ipheader, submessage_arena);
    }
    
  } else {
    
  }
  ipheader_ = ipheader;
  // @@protoc_insertion_point(field_set_allocated:netsensor.ProtoData.ipHeader)
}

// .netsensor.ProtoDatagramInfo dgram = 4;
inline bool ProtoData::has_dgram() const {
  return this != internal_default_instance() && dgram_ != NULL;
}
inline void ProtoData::clear_dgram() {
  if (GetArenaNoVirtual() == NULL && dgram_ != NULL) {
    delete dgram_;
  }
  dgram_ = NULL;
}
inline const ::netsensor::ProtoDatagramInfo& ProtoData::_internal_dgram() const {
  return *dgram_;
}
inline const ::netsensor::ProtoDatagramInfo& ProtoData::dgram() const {
  const ::netsensor::ProtoDatagramInfo* p = dgram_;
  // @@protoc_insertion_point(field_get:netsensor.ProtoData.dgram)
  return p != NULL ? *p : *reinterpret_cast<const ::netsensor::ProtoDatagramInfo*>(
      &::netsensor::_ProtoDatagramInfo_default_instance_);
}
inline ::netsensor::ProtoDatagramInfo* ProtoData::release_dgram() {
  // @@protoc_insertion_point(field_release:netsensor.ProtoData.dgram)
  
  ::netsensor::ProtoDatagramInfo* temp = dgram_;
  dgram_ = NULL;
  return temp;
}
inline ::netsensor::ProtoDatagramInfo* ProtoData::mutable_dgram() {
  
  if (dgram_ == NULL) {
    auto* p = CreateMaybeMessage<::netsensor::ProtoDatagramInfo>(GetArenaNoVirtual());
    dgram_ = p;
  }
  // @@protoc_insertion_point(field_mutable:netsensor.ProtoData.dgram)
  return dgram_;
}
inline void ProtoData::set_allocated_dgram(::netsensor::ProtoDatagramInfo* dgram) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete dgram_;
  }
  if (dgram) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      dgram = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, dgram, submessage_arena);
    }
    
  } else {
    
  }
  dgram_ = dgram;
  // @@protoc_insertion_point(field_set_allocated:netsensor.ProtoData.dgram)
}

// .netsensor.ProtoICMPTime icmpTimestamp = 5;
inline bool ProtoData::has_icmptimestamp() const {
  return this != internal_default_instance() && icmptimestamp_ != NULL;
}
inline void ProtoData::clear_icmptimestamp() {
  if (GetArenaNoVirtual() == NULL && icmptimestamp_ != NULL) {
    delete icmptimestamp_;
  }
  icmptimestamp_ = NULL;
}
inline const ::netsensor::ProtoICMPTime& ProtoData::_internal_icmptimestamp() const {
  return *icmptimestamp_;
}
inline const ::netsensor::ProtoICMPTime& ProtoData::icmptimestamp() const {
  const ::netsensor::ProtoICMPTime* p = icmptimestamp_;
  // @@protoc_insertion_point(field_get:netsensor.ProtoData.icmpTimestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::netsensor::ProtoICMPTime*>(
      &::netsensor::_ProtoICMPTime_default_instance_);
}
inline ::netsensor::ProtoICMPTime* ProtoData::release_icmptimestamp() {
  // @@protoc_insertion_point(field_release:netsensor.ProtoData.icmpTimestamp)
  
  ::netsensor::ProtoICMPTime* temp = icmptimestamp_;
  icmptimestamp_ = NULL;
  return temp;
}
inline ::netsensor::ProtoICMPTime* ProtoData::mutable_icmptimestamp() {
  
  if (icmptimestamp_ == NULL) {
    auto* p = CreateMaybeMessage<::netsensor::ProtoICMPTime>(GetArenaNoVirtual());
    icmptimestamp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:netsensor.ProtoData.icmpTimestamp)
  return icmptimestamp_;
}
inline void ProtoData::set_allocated_icmptimestamp(::netsensor::ProtoICMPTime* icmptimestamp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete icmptimestamp_;
  }
  if (icmptimestamp) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      icmptimestamp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, icmptimestamp, submessage_arena);
    }
    
  } else {
    
  }
  icmptimestamp_ = icmptimestamp;
  // @@protoc_insertion_point(field_set_allocated:netsensor.ProtoData.icmpTimestamp)
}

// repeated .netsensor.ProtoExtraAddresses extraAddresses = 6;
inline int ProtoData::extraaddresses_size() const {
  return extraaddresses_.size();
}
inline void ProtoData::clear_extraaddresses() {
  extraaddresses_.Clear();
}
inline ::netsensor::ProtoExtraAddresses* ProtoData::mutable_extraaddresses(int index) {
  // @@protoc_insertion_point(field_mutable:netsensor.ProtoData.extraAddresses)
  return extraaddresses_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::netsensor::ProtoExtraAddresses >*
ProtoData::mutable_extraaddresses() {
  // @@protoc_insertion_point(field_mutable_list:netsensor.ProtoData.extraAddresses)
  return &extraaddresses_;
}
inline const ::netsensor::ProtoExtraAddresses& ProtoData::extraaddresses(int index) const {
  // @@protoc_insertion_point(field_get:netsensor.ProtoData.extraAddresses)
  return extraaddresses_.Get(index);
}
inline ::netsensor::ProtoExtraAddresses* ProtoData::add_extraaddresses() {
  // @@protoc_insertion_point(field_add:netsensor.ProtoData.extraAddresses)
  return extraaddresses_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::netsensor::ProtoExtraAddresses >&
ProtoData::extraaddresses() const {
  // @@protoc_insertion_point(field_list:netsensor.ProtoData.extraAddresses)
  return extraaddresses_;
}

// -------------------------------------------------------------------

// ProtoIdentification

// uint32 identifier = 1;
inline void ProtoIdentification::clear_identifier() {
  identifier_ = 0u;
}
inline ::google::protobuf::uint32 ProtoIdentification::identifier() const {
  // @@protoc_insertion_point(field_get:netsensor.ProtoIdentification.identifier)
  return identifier_;
}
inline void ProtoIdentification::set_identifier(::google::protobuf::uint32 value) {
  
  identifier_ = value;
  // @@protoc_insertion_point(field_set:netsensor.ProtoIdentification.identifier)
}

// uint32 sequenceNumber = 2;
inline void ProtoIdentification::clear_sequencenumber() {
  sequencenumber_ = 0u;
}
inline ::google::protobuf::uint32 ProtoIdentification::sequencenumber() const {
  // @@protoc_insertion_point(field_get:netsensor.ProtoIdentification.sequenceNumber)
  return sequencenumber_;
}
inline void ProtoIdentification::set_sequencenumber(::google::protobuf::uint32 value) {
  
  sequencenumber_ = value;
  // @@protoc_insertion_point(field_set:netsensor.ProtoIdentification.sequenceNumber)
}

// -------------------------------------------------------------------

// ProtoIpHeader

// uint32 tos = 1;
inline void ProtoIpHeader::clear_tos() {
  tos_ = 0u;
}
inline ::google::protobuf::uint32 ProtoIpHeader::tos() const {
  // @@protoc_insertion_point(field_get:netsensor.ProtoIpHeader.tos)
  return tos_;
}
inline void ProtoIpHeader::set_tos(::google::protobuf::uint32 value) {
  
  tos_ = value;
  // @@protoc_insertion_point(field_set:netsensor.ProtoIpHeader.tos)
}

// uint32 length = 2;
inline void ProtoIpHeader::clear_length() {
  length_ = 0u;
}
inline ::google::protobuf::uint32 ProtoIpHeader::length() const {
  // @@protoc_insertion_point(field_get:netsensor.ProtoIpHeader.length)
  return length_;
}
inline void ProtoIpHeader::set_length(::google::protobuf::uint32 value) {
  
  length_ = value;
  // @@protoc_insertion_point(field_set:netsensor.ProtoIpHeader.length)
}

// uint32 protocol = 3;
inline void ProtoIpHeader::clear_protocol() {
  protocol_ = 0u;
}
inline ::google::protobuf::uint32 ProtoIpHeader::protocol() const {
  // @@protoc_insertion_point(field_get:netsensor.ProtoIpHeader.protocol)
  return protocol_;
}
inline void ProtoIpHeader::set_protocol(::google::protobuf::uint32 value) {
  
  protocol_ = value;
  // @@protoc_insertion_point(field_set:netsensor.ProtoIpHeader.protocol)
}

// string origSourceIPAddr = 4;
inline void ProtoIpHeader::clear_origsourceipaddr() {
  origsourceipaddr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ProtoIpHeader::origsourceipaddr() const {
  // @@protoc_insertion_point(field_get:netsensor.ProtoIpHeader.origSourceIPAddr)
  return origsourceipaddr_.GetNoArena();
}
inline void ProtoIpHeader::set_origsourceipaddr(const ::std::string& value) {
  
  origsourceipaddr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netsensor.ProtoIpHeader.origSourceIPAddr)
}
#if LANG_CXX11
inline void ProtoIpHeader::set_origsourceipaddr(::std::string&& value) {
  
  origsourceipaddr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netsensor.ProtoIpHeader.origSourceIPAddr)
}
#endif
inline void ProtoIpHeader::set_origsourceipaddr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  origsourceipaddr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netsensor.ProtoIpHeader.origSourceIPAddr)
}
inline void ProtoIpHeader::set_origsourceipaddr(const char* value, size_t size) {
  
  origsourceipaddr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netsensor.ProtoIpHeader.origSourceIPAddr)
}
inline ::std::string* ProtoIpHeader::mutable_origsourceipaddr() {
  
  // @@protoc_insertion_point(field_mutable:netsensor.ProtoIpHeader.origSourceIPAddr)
  return origsourceipaddr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProtoIpHeader::release_origsourceipaddr() {
  // @@protoc_insertion_point(field_release:netsensor.ProtoIpHeader.origSourceIPAddr)
  
  return origsourceipaddr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProtoIpHeader::set_allocated_origsourceipaddr(::std::string* origsourceipaddr) {
  if (origsourceipaddr != NULL) {
    
  } else {
    
  }
  origsourceipaddr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), origsourceipaddr);
  // @@protoc_insertion_point(field_set_allocated:netsensor.ProtoIpHeader.origSourceIPAddr)
}

// string origDestIPAddr = 5;
inline void ProtoIpHeader::clear_origdestipaddr() {
  origdestipaddr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ProtoIpHeader::origdestipaddr() const {
  // @@protoc_insertion_point(field_get:netsensor.ProtoIpHeader.origDestIPAddr)
  return origdestipaddr_.GetNoArena();
}
inline void ProtoIpHeader::set_origdestipaddr(const ::std::string& value) {
  
  origdestipaddr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netsensor.ProtoIpHeader.origDestIPAddr)
}
#if LANG_CXX11
inline void ProtoIpHeader::set_origdestipaddr(::std::string&& value) {
  
  origdestipaddr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netsensor.ProtoIpHeader.origDestIPAddr)
}
#endif
inline void ProtoIpHeader::set_origdestipaddr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  origdestipaddr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netsensor.ProtoIpHeader.origDestIPAddr)
}
inline void ProtoIpHeader::set_origdestipaddr(const char* value, size_t size) {
  
  origdestipaddr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netsensor.ProtoIpHeader.origDestIPAddr)
}
inline ::std::string* ProtoIpHeader::mutable_origdestipaddr() {
  
  // @@protoc_insertion_point(field_mutable:netsensor.ProtoIpHeader.origDestIPAddr)
  return origdestipaddr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProtoIpHeader::release_origdestipaddr() {
  // @@protoc_insertion_point(field_release:netsensor.ProtoIpHeader.origDestIPAddr)
  
  return origdestipaddr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProtoIpHeader::set_allocated_origdestipaddr(::std::string* origdestipaddr) {
  if (origdestipaddr != NULL) {
    
  } else {
    
  }
  origdestipaddr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), origdestipaddr);
  // @@protoc_insertion_point(field_set_allocated:netsensor.ProtoIpHeader.origDestIPAddr)
}

// -------------------------------------------------------------------

// ProtoDatagramInfo

// uint32 sourcePort = 1;
inline void ProtoDatagramInfo::clear_sourceport() {
  sourceport_ = 0u;
}
inline ::google::protobuf::uint32 ProtoDatagramInfo::sourceport() const {
  // @@protoc_insertion_point(field_get:netsensor.ProtoDatagramInfo.sourcePort)
  return sourceport_;
}
inline void ProtoDatagramInfo::set_sourceport(::google::protobuf::uint32 value) {
  
  sourceport_ = value;
  // @@protoc_insertion_point(field_set:netsensor.ProtoDatagramInfo.sourcePort)
}

// uint32 destPort = 2;
inline void ProtoDatagramInfo::clear_destport() {
  destport_ = 0u;
}
inline ::google::protobuf::uint32 ProtoDatagramInfo::destport() const {
  // @@protoc_insertion_point(field_get:netsensor.ProtoDatagramInfo.destPort)
  return destport_;
}
inline void ProtoDatagramInfo::set_destport(::google::protobuf::uint32 value) {
  
  destport_ = value;
  // @@protoc_insertion_point(field_set:netsensor.ProtoDatagramInfo.destPort)
}

// -------------------------------------------------------------------

// ProtoICMPTime

// uint32 originateTimestamp = 1;
inline void ProtoICMPTime::clear_originatetimestamp() {
  originatetimestamp_ = 0u;
}
inline ::google::protobuf::uint32 ProtoICMPTime::originatetimestamp() const {
  // @@protoc_insertion_point(field_get:netsensor.ProtoICMPTime.originateTimestamp)
  return originatetimestamp_;
}
inline void ProtoICMPTime::set_originatetimestamp(::google::protobuf::uint32 value) {
  
  originatetimestamp_ = value;
  // @@protoc_insertion_point(field_set:netsensor.ProtoICMPTime.originateTimestamp)
}

// uint32 receiveTimestamp = 2;
inline void ProtoICMPTime::clear_receivetimestamp() {
  receivetimestamp_ = 0u;
}
inline ::google::protobuf::uint32 ProtoICMPTime::receivetimestamp() const {
  // @@protoc_insertion_point(field_get:netsensor.ProtoICMPTime.receiveTimestamp)
  return receivetimestamp_;
}
inline void ProtoICMPTime::set_receivetimestamp(::google::protobuf::uint32 value) {
  
  receivetimestamp_ = value;
  // @@protoc_insertion_point(field_set:netsensor.ProtoICMPTime.receiveTimestamp)
}

// uint32 transmitTimestamp = 3;
inline void ProtoICMPTime::clear_transmittimestamp() {
  transmittimestamp_ = 0u;
}
inline ::google::protobuf::uint32 ProtoICMPTime::transmittimestamp() const {
  // @@protoc_insertion_point(field_get:netsensor.ProtoICMPTime.transmitTimestamp)
  return transmittimestamp_;
}
inline void ProtoICMPTime::set_transmittimestamp(::google::protobuf::uint32 value) {
  
  transmittimestamp_ = value;
  // @@protoc_insertion_point(field_set:netsensor.ProtoICMPTime.transmitTimestamp)
}

// -------------------------------------------------------------------

// ProtoExtraAddresses

// string IPAddress = 1;
inline void ProtoExtraAddresses::clear_ipaddress() {
  ipaddress_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ProtoExtraAddresses::ipaddress() const {
  // @@protoc_insertion_point(field_get:netsensor.ProtoExtraAddresses.IPAddress)
  return ipaddress_.GetNoArena();
}
inline void ProtoExtraAddresses::set_ipaddress(const ::std::string& value) {
  
  ipaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netsensor.ProtoExtraAddresses.IPAddress)
}
#if LANG_CXX11
inline void ProtoExtraAddresses::set_ipaddress(::std::string&& value) {
  
  ipaddress_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netsensor.ProtoExtraAddresses.IPAddress)
}
#endif
inline void ProtoExtraAddresses::set_ipaddress(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ipaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netsensor.ProtoExtraAddresses.IPAddress)
}
inline void ProtoExtraAddresses::set_ipaddress(const char* value, size_t size) {
  
  ipaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netsensor.ProtoExtraAddresses.IPAddress)
}
inline ::std::string* ProtoExtraAddresses::mutable_ipaddress() {
  
  // @@protoc_insertion_point(field_mutable:netsensor.ProtoExtraAddresses.IPAddress)
  return ipaddress_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProtoExtraAddresses::release_ipaddress() {
  // @@protoc_insertion_point(field_release:netsensor.ProtoExtraAddresses.IPAddress)
  
  return ipaddress_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProtoExtraAddresses::set_allocated_ipaddress(::std::string* ipaddress) {
  if (ipaddress != NULL) {
    
  } else {
    
  }
  ipaddress_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ipaddress);
  // @@protoc_insertion_point(field_set_allocated:netsensor.ProtoExtraAddresses.IPAddress)
}

// uint32 timesRepeated = 2;
inline void ProtoExtraAddresses::clear_timesrepeated() {
  timesrepeated_ = 0u;
}
inline ::google::protobuf::uint32 ProtoExtraAddresses::timesrepeated() const {
  // @@protoc_insertion_point(field_get:netsensor.ProtoExtraAddresses.timesRepeated)
  return timesrepeated_;
}
inline void ProtoExtraAddresses::set_timesrepeated(::google::protobuf::uint32 value) {
  
  timesrepeated_ = value;
  // @@protoc_insertion_point(field_set:netsensor.ProtoExtraAddresses.timesRepeated)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace netsensor

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_icmpinfo_2eproto
