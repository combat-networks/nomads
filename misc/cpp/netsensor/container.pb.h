// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: container.proto

#ifndef PROTOBUF_container_2eproto__INCLUDED
#define PROTOBUF_container_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
#include "node.pb.h"
#include "grump.pb.h"
#include "info.pb.h"
#include "traffic.pb.h"
#include "topology.pb.h"
#include "networkhealth.pb.h"
// @@protoc_insertion_point(includes)

namespace ddam {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_container_2eproto();
void protobuf_AssignDesc_container_2eproto();
void protobuf_ShutdownFile_container_2eproto();

class Container;

enum DataType {
  INFO = 0,
  GROUP = 1,
  LINK = 2,
  TRAFFIC = 3,
  TOPOLOGY = 4,
  TOPOLOGY_PARTS = 5,
  NETWORK_HEALTH = 6,
  NODE = 7,
  DataType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DataType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DataType_IsValid(int value);
const DataType DataType_MIN = INFO;
const DataType DataType_MAX = NODE;
const int DataType_ARRAYSIZE = DataType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DataType_descriptor();
inline const ::std::string& DataType_Name(DataType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DataType_descriptor(), value);
}
inline bool DataType_Parse(
    const ::std::string& name, DataType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DataType>(
    DataType_descriptor(), name, value);
}
enum MessageType {
  UPDATE_DATA = 0,
  UPDATE_WORLD_STATE = 1,
  MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MessageType_IsValid(int value);
const MessageType MessageType_MIN = UPDATE_DATA;
const MessageType MessageType_MAX = UPDATE_WORLD_STATE;
const int MessageType_ARRAYSIZE = MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageType_descriptor();
inline const ::std::string& MessageType_Name(MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageType_descriptor(), value);
}
inline bool MessageType_Parse(
    const ::std::string& name, MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageType>(
    MessageType_descriptor(), name, value);
}
enum TransportType {
  UDP_UNICAST = 0,
  UDP_MULTICAST = 1,
  TCP = 2,
  TransportType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TransportType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TransportType_IsValid(int value);
const TransportType TransportType_MIN = UDP_UNICAST;
const TransportType TransportType_MAX = TCP;
const int TransportType_ARRAYSIZE = TransportType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TransportType_descriptor();
inline const ::std::string& TransportType_Name(TransportType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TransportType_descriptor(), value);
}
inline bool TransportType_Parse(
    const ::std::string& name, TransportType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TransportType>(
    TransportType_descriptor(), name, value);
}
// ===================================================================

class Container : public ::google::protobuf::Message {
 public:
  Container();
  virtual ~Container();

  Container(const Container& from);

  inline Container& operator=(const Container& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Container& default_instance();

  void Swap(Container* other);

  // implements Message ----------------------------------------------

  inline Container* New() const { return New(NULL); }

  Container* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Container& from);
  void MergeFrom(const Container& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Container* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string senderId = 1;
  void clear_senderid();
  static const int kSenderIdFieldNumber = 1;
  const ::std::string& senderid() const;
  void set_senderid(const ::std::string& value);
  void set_senderid(const char* value);
  void set_senderid(const char* value, size_t size);
  ::std::string* mutable_senderid();
  ::std::string* release_senderid();
  void set_allocated_senderid(::std::string* senderid);

  // optional uint32 senderIpAddress = 2;
  void clear_senderipaddress();
  static const int kSenderIpAddressFieldNumber = 2;
  ::google::protobuf::uint32 senderipaddress() const;
  void set_senderipaddress(::google::protobuf::uint32 value);

  // optional string recipientId = 3;
  void clear_recipientid();
  static const int kRecipientIdFieldNumber = 3;
  const ::std::string& recipientid() const;
  void set_recipientid(const ::std::string& value);
  void set_recipientid(const char* value);
  void set_recipientid(const char* value, size_t size);
  ::std::string* mutable_recipientid();
  ::std::string* release_recipientid();
  void set_allocated_recipientid(::std::string* recipientid);

  // optional string groupName = 4;
  void clear_groupname();
  static const int kGroupNameFieldNumber = 4;
  const ::std::string& groupname() const;
  void set_groupname(const ::std::string& value);
  void set_groupname(const char* value);
  void set_groupname(const char* value, size_t size);
  ::std::string* mutable_groupname();
  ::std::string* release_groupname();
  void set_allocated_groupname(::std::string* groupname);

  // optional .ddam.TransportType transportType = 5;
  void clear_transporttype();
  static const int kTransportTypeFieldNumber = 5;
  ::ddam::TransportType transporttype() const;
  void set_transporttype(::ddam::TransportType value);

  // optional .ddam.MessageType messageType = 6;
  void clear_messagetype();
  static const int kMessageTypeFieldNumber = 6;
  ::ddam::MessageType messagetype() const;
  void set_messagetype(::ddam::MessageType value);

  // optional .ddam.DataType dataType = 7;
  void clear_datatype();
  static const int kDataTypeFieldNumber = 7;
  ::ddam::DataType datatype() const;
  void set_datatype(::ddam::DataType value);

  // optional string dataNodeId = 8;
  void clear_datanodeid();
  static const int kDataNodeIdFieldNumber = 8;
  const ::std::string& datanodeid() const;
  void set_datanodeid(const ::std::string& value);
  void set_datanodeid(const char* value);
  void set_datanodeid(const char* value, size_t size);
  ::std::string* mutable_datanodeid();
  ::std::string* release_datanodeid();
  void set_allocated_datanodeid(::std::string* datanodeid);

  // optional .ddam.Node node = 9;
  bool has_node() const;
  void clear_node();
  static const int kNodeFieldNumber = 9;
  const ::ddam::Node& node() const;
  ::ddam::Node* mutable_node();
  ::ddam::Node* release_node();
  void set_allocated_node(::ddam::Node* node);

  // optional .ddam.Info info = 10;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 10;
  const ::ddam::Info& info() const;
  ::ddam::Info* mutable_info();
  ::ddam::Info* release_info();
  void set_allocated_info(::ddam::Info* info);

  // repeated .ddam.Group groups = 11;
  int groups_size() const;
  void clear_groups();
  static const int kGroupsFieldNumber = 11;
  const ::ddam::Group& groups(int index) const;
  ::ddam::Group* mutable_groups(int index);
  ::ddam::Group* add_groups();
  ::google::protobuf::RepeatedPtrField< ::ddam::Group >*
      mutable_groups();
  const ::google::protobuf::RepeatedPtrField< ::ddam::Group >&
      groups() const;

  // repeated .ddam.Link links = 12;
  int links_size() const;
  void clear_links();
  static const int kLinksFieldNumber = 12;
  const ::ddam::Link& links(int index) const;
  ::ddam::Link* mutable_links(int index);
  ::ddam::Link* add_links();
  ::google::protobuf::RepeatedPtrField< ::ddam::Link >*
      mutable_links();
  const ::google::protobuf::RepeatedPtrField< ::ddam::Link >&
      links() const;

  // optional .ddam.Traffic traffic = 13;
  bool has_traffic() const;
  void clear_traffic();
  static const int kTrafficFieldNumber = 13;
  const ::ddam::Traffic& traffic() const;
  ::ddam::Traffic* mutable_traffic();
  ::ddam::Traffic* release_traffic();
  void set_allocated_traffic(::ddam::Traffic* traffic);

  // optional .ddam.Topology topology = 14;
  bool has_topology() const;
  void clear_topology();
  static const int kTopologyFieldNumber = 14;
  const ::ddam::Topology& topology() const;
  ::ddam::Topology* mutable_topology();
  ::ddam::Topology* release_topology();
  void set_allocated_topology(::ddam::Topology* topology);

  // optional .ddam.TopologyParts topologyParts = 15;
  bool has_topologyparts() const;
  void clear_topologyparts();
  static const int kTopologyPartsFieldNumber = 15;
  const ::ddam::TopologyParts& topologyparts() const;
  ::ddam::TopologyParts* mutable_topologyparts();
  ::ddam::TopologyParts* release_topologyparts();
  void set_allocated_topologyparts(::ddam::TopologyParts* topologyparts);

  // optional .ddam.NetworkHealth networkHealth = 16;
  bool has_networkhealth() const;
  void clear_networkhealth();
  static const int kNetworkHealthFieldNumber = 16;
  const ::ddam::NetworkHealth& networkhealth() const;
  ::ddam::NetworkHealth* mutable_networkhealth();
  ::ddam::NetworkHealth* release_networkhealth();
  void set_allocated_networkhealth(::ddam::NetworkHealth* networkhealth);

  // optional .google.protobuf.Timestamp timestamp = 17;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 17;
  const ::google::protobuf::Timestamp& timestamp() const;
  ::google::protobuf::Timestamp* mutable_timestamp();
  ::google::protobuf::Timestamp* release_timestamp();
  void set_allocated_timestamp(::google::protobuf::Timestamp* timestamp);

  // @@protoc_insertion_point(class_scope:ddam.Container)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr senderid_;
  ::google::protobuf::internal::ArenaStringPtr recipientid_;
  ::google::protobuf::uint32 senderipaddress_;
  int transporttype_;
  ::google::protobuf::internal::ArenaStringPtr groupname_;
  int messagetype_;
  int datatype_;
  ::google::protobuf::internal::ArenaStringPtr datanodeid_;
  ::ddam::Node* node_;
  ::ddam::Info* info_;
  ::google::protobuf::RepeatedPtrField< ::ddam::Group > groups_;
  ::google::protobuf::RepeatedPtrField< ::ddam::Link > links_;
  ::ddam::Traffic* traffic_;
  ::ddam::Topology* topology_;
  ::ddam::TopologyParts* topologyparts_;
  ::ddam::NetworkHealth* networkhealth_;
  ::google::protobuf::Timestamp* timestamp_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_container_2eproto();
  friend void protobuf_AssignDesc_container_2eproto();
  friend void protobuf_ShutdownFile_container_2eproto();

  void InitAsDefaultInstance();
  static Container* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Container

// optional string senderId = 1;
inline void Container::clear_senderid() {
  senderid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Container::senderid() const {
  // @@protoc_insertion_point(field_get:ddam.Container.senderId)
  return senderid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Container::set_senderid(const ::std::string& value) {
  
  senderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ddam.Container.senderId)
}
inline void Container::set_senderid(const char* value) {
  
  senderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ddam.Container.senderId)
}
inline void Container::set_senderid(const char* value, size_t size) {
  
  senderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ddam.Container.senderId)
}
inline ::std::string* Container::mutable_senderid() {
  
  // @@protoc_insertion_point(field_mutable:ddam.Container.senderId)
  return senderid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Container::release_senderid() {
  
  return senderid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Container::set_allocated_senderid(::std::string* senderid) {
  if (senderid != NULL) {
    
  } else {
    
  }
  senderid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), senderid);
  // @@protoc_insertion_point(field_set_allocated:ddam.Container.senderId)
}

// optional uint32 senderIpAddress = 2;
inline void Container::clear_senderipaddress() {
  senderipaddress_ = 0u;
}
inline ::google::protobuf::uint32 Container::senderipaddress() const {
  // @@protoc_insertion_point(field_get:ddam.Container.senderIpAddress)
  return senderipaddress_;
}
inline void Container::set_senderipaddress(::google::protobuf::uint32 value) {
  
  senderipaddress_ = value;
  // @@protoc_insertion_point(field_set:ddam.Container.senderIpAddress)
}

// optional string recipientId = 3;
inline void Container::clear_recipientid() {
  recipientid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Container::recipientid() const {
  // @@protoc_insertion_point(field_get:ddam.Container.recipientId)
  return recipientid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Container::set_recipientid(const ::std::string& value) {
  
  recipientid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ddam.Container.recipientId)
}
inline void Container::set_recipientid(const char* value) {
  
  recipientid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ddam.Container.recipientId)
}
inline void Container::set_recipientid(const char* value, size_t size) {
  
  recipientid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ddam.Container.recipientId)
}
inline ::std::string* Container::mutable_recipientid() {
  
  // @@protoc_insertion_point(field_mutable:ddam.Container.recipientId)
  return recipientid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Container::release_recipientid() {
  
  return recipientid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Container::set_allocated_recipientid(::std::string* recipientid) {
  if (recipientid != NULL) {
    
  } else {
    
  }
  recipientid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), recipientid);
  // @@protoc_insertion_point(field_set_allocated:ddam.Container.recipientId)
}

// optional string groupName = 4;
inline void Container::clear_groupname() {
  groupname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Container::groupname() const {
  // @@protoc_insertion_point(field_get:ddam.Container.groupName)
  return groupname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Container::set_groupname(const ::std::string& value) {
  
  groupname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ddam.Container.groupName)
}
inline void Container::set_groupname(const char* value) {
  
  groupname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ddam.Container.groupName)
}
inline void Container::set_groupname(const char* value, size_t size) {
  
  groupname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ddam.Container.groupName)
}
inline ::std::string* Container::mutable_groupname() {
  
  // @@protoc_insertion_point(field_mutable:ddam.Container.groupName)
  return groupname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Container::release_groupname() {
  
  return groupname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Container::set_allocated_groupname(::std::string* groupname) {
  if (groupname != NULL) {
    
  } else {
    
  }
  groupname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), groupname);
  // @@protoc_insertion_point(field_set_allocated:ddam.Container.groupName)
}

// optional .ddam.TransportType transportType = 5;
inline void Container::clear_transporttype() {
  transporttype_ = 0;
}
inline ::ddam::TransportType Container::transporttype() const {
  // @@protoc_insertion_point(field_get:ddam.Container.transportType)
  return static_cast< ::ddam::TransportType >(transporttype_);
}
inline void Container::set_transporttype(::ddam::TransportType value) {
  
  transporttype_ = value;
  // @@protoc_insertion_point(field_set:ddam.Container.transportType)
}

// optional .ddam.MessageType messageType = 6;
inline void Container::clear_messagetype() {
  messagetype_ = 0;
}
inline ::ddam::MessageType Container::messagetype() const {
  // @@protoc_insertion_point(field_get:ddam.Container.messageType)
  return static_cast< ::ddam::MessageType >(messagetype_);
}
inline void Container::set_messagetype(::ddam::MessageType value) {
  
  messagetype_ = value;
  // @@protoc_insertion_point(field_set:ddam.Container.messageType)
}

// optional .ddam.DataType dataType = 7;
inline void Container::clear_datatype() {
  datatype_ = 0;
}
inline ::ddam::DataType Container::datatype() const {
  // @@protoc_insertion_point(field_get:ddam.Container.dataType)
  return static_cast< ::ddam::DataType >(datatype_);
}
inline void Container::set_datatype(::ddam::DataType value) {
  
  datatype_ = value;
  // @@protoc_insertion_point(field_set:ddam.Container.dataType)
}

// optional string dataNodeId = 8;
inline void Container::clear_datanodeid() {
  datanodeid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Container::datanodeid() const {
  // @@protoc_insertion_point(field_get:ddam.Container.dataNodeId)
  return datanodeid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Container::set_datanodeid(const ::std::string& value) {
  
  datanodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ddam.Container.dataNodeId)
}
inline void Container::set_datanodeid(const char* value) {
  
  datanodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ddam.Container.dataNodeId)
}
inline void Container::set_datanodeid(const char* value, size_t size) {
  
  datanodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ddam.Container.dataNodeId)
}
inline ::std::string* Container::mutable_datanodeid() {
  
  // @@protoc_insertion_point(field_mutable:ddam.Container.dataNodeId)
  return datanodeid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Container::release_datanodeid() {
  
  return datanodeid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Container::set_allocated_datanodeid(::std::string* datanodeid) {
  if (datanodeid != NULL) {
    
  } else {
    
  }
  datanodeid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), datanodeid);
  // @@protoc_insertion_point(field_set_allocated:ddam.Container.dataNodeId)
}

// optional .ddam.Node node = 9;
inline bool Container::has_node() const {
  return !_is_default_instance_ && node_ != NULL;
}
inline void Container::clear_node() {
  if (GetArenaNoVirtual() == NULL && node_ != NULL) delete node_;
  node_ = NULL;
}
inline const ::ddam::Node& Container::node() const {
  // @@protoc_insertion_point(field_get:ddam.Container.node)
  return node_ != NULL ? *node_ : *default_instance_->node_;
}
inline ::ddam::Node* Container::mutable_node() {
  
  if (node_ == NULL) {
    node_ = new ::ddam::Node;
  }
  // @@protoc_insertion_point(field_mutable:ddam.Container.node)
  return node_;
}
inline ::ddam::Node* Container::release_node() {
  
  ::ddam::Node* temp = node_;
  node_ = NULL;
  return temp;
}
inline void Container::set_allocated_node(::ddam::Node* node) {
  delete node_;
  node_ = node;
  if (node) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ddam.Container.node)
}

// optional .ddam.Info info = 10;
inline bool Container::has_info() const {
  return !_is_default_instance_ && info_ != NULL;
}
inline void Container::clear_info() {
  if (GetArenaNoVirtual() == NULL && info_ != NULL) delete info_;
  info_ = NULL;
}
inline const ::ddam::Info& Container::info() const {
  // @@protoc_insertion_point(field_get:ddam.Container.info)
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::ddam::Info* Container::mutable_info() {
  
  if (info_ == NULL) {
    info_ = new ::ddam::Info;
  }
  // @@protoc_insertion_point(field_mutable:ddam.Container.info)
  return info_;
}
inline ::ddam::Info* Container::release_info() {
  
  ::ddam::Info* temp = info_;
  info_ = NULL;
  return temp;
}
inline void Container::set_allocated_info(::ddam::Info* info) {
  delete info_;
  info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ddam.Container.info)
}

// repeated .ddam.Group groups = 11;
inline int Container::groups_size() const {
  return groups_.size();
}
inline void Container::clear_groups() {
  groups_.Clear();
}
inline const ::ddam::Group& Container::groups(int index) const {
  // @@protoc_insertion_point(field_get:ddam.Container.groups)
  return groups_.Get(index);
}
inline ::ddam::Group* Container::mutable_groups(int index) {
  // @@protoc_insertion_point(field_mutable:ddam.Container.groups)
  return groups_.Mutable(index);
}
inline ::ddam::Group* Container::add_groups() {
  // @@protoc_insertion_point(field_add:ddam.Container.groups)
  return groups_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ddam::Group >*
Container::mutable_groups() {
  // @@protoc_insertion_point(field_mutable_list:ddam.Container.groups)
  return &groups_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ddam::Group >&
Container::groups() const {
  // @@protoc_insertion_point(field_list:ddam.Container.groups)
  return groups_;
}

// repeated .ddam.Link links = 12;
inline int Container::links_size() const {
  return links_.size();
}
inline void Container::clear_links() {
  links_.Clear();
}
inline const ::ddam::Link& Container::links(int index) const {
  // @@protoc_insertion_point(field_get:ddam.Container.links)
  return links_.Get(index);
}
inline ::ddam::Link* Container::mutable_links(int index) {
  // @@protoc_insertion_point(field_mutable:ddam.Container.links)
  return links_.Mutable(index);
}
inline ::ddam::Link* Container::add_links() {
  // @@protoc_insertion_point(field_add:ddam.Container.links)
  return links_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ddam::Link >*
Container::mutable_links() {
  // @@protoc_insertion_point(field_mutable_list:ddam.Container.links)
  return &links_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ddam::Link >&
Container::links() const {
  // @@protoc_insertion_point(field_list:ddam.Container.links)
  return links_;
}

// optional .ddam.Traffic traffic = 13;
inline bool Container::has_traffic() const {
  return !_is_default_instance_ && traffic_ != NULL;
}
inline void Container::clear_traffic() {
  if (GetArenaNoVirtual() == NULL && traffic_ != NULL) delete traffic_;
  traffic_ = NULL;
}
inline const ::ddam::Traffic& Container::traffic() const {
  // @@protoc_insertion_point(field_get:ddam.Container.traffic)
  return traffic_ != NULL ? *traffic_ : *default_instance_->traffic_;
}
inline ::ddam::Traffic* Container::mutable_traffic() {
  
  if (traffic_ == NULL) {
    traffic_ = new ::ddam::Traffic;
  }
  // @@protoc_insertion_point(field_mutable:ddam.Container.traffic)
  return traffic_;
}
inline ::ddam::Traffic* Container::release_traffic() {
  
  ::ddam::Traffic* temp = traffic_;
  traffic_ = NULL;
  return temp;
}
inline void Container::set_allocated_traffic(::ddam::Traffic* traffic) {
  delete traffic_;
  traffic_ = traffic;
  if (traffic) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ddam.Container.traffic)
}

// optional .ddam.Topology topology = 14;
inline bool Container::has_topology() const {
  return !_is_default_instance_ && topology_ != NULL;
}
inline void Container::clear_topology() {
  if (GetArenaNoVirtual() == NULL && topology_ != NULL) delete topology_;
  topology_ = NULL;
}
inline const ::ddam::Topology& Container::topology() const {
  // @@protoc_insertion_point(field_get:ddam.Container.topology)
  return topology_ != NULL ? *topology_ : *default_instance_->topology_;
}
inline ::ddam::Topology* Container::mutable_topology() {
  
  if (topology_ == NULL) {
    topology_ = new ::ddam::Topology;
  }
  // @@protoc_insertion_point(field_mutable:ddam.Container.topology)
  return topology_;
}
inline ::ddam::Topology* Container::release_topology() {
  
  ::ddam::Topology* temp = topology_;
  topology_ = NULL;
  return temp;
}
inline void Container::set_allocated_topology(::ddam::Topology* topology) {
  delete topology_;
  topology_ = topology;
  if (topology) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ddam.Container.topology)
}

// optional .ddam.TopologyParts topologyParts = 15;
inline bool Container::has_topologyparts() const {
  return !_is_default_instance_ && topologyparts_ != NULL;
}
inline void Container::clear_topologyparts() {
  if (GetArenaNoVirtual() == NULL && topologyparts_ != NULL) delete topologyparts_;
  topologyparts_ = NULL;
}
inline const ::ddam::TopologyParts& Container::topologyparts() const {
  // @@protoc_insertion_point(field_get:ddam.Container.topologyParts)
  return topologyparts_ != NULL ? *topologyparts_ : *default_instance_->topologyparts_;
}
inline ::ddam::TopologyParts* Container::mutable_topologyparts() {
  
  if (topologyparts_ == NULL) {
    topologyparts_ = new ::ddam::TopologyParts;
  }
  // @@protoc_insertion_point(field_mutable:ddam.Container.topologyParts)
  return topologyparts_;
}
inline ::ddam::TopologyParts* Container::release_topologyparts() {
  
  ::ddam::TopologyParts* temp = topologyparts_;
  topologyparts_ = NULL;
  return temp;
}
inline void Container::set_allocated_topologyparts(::ddam::TopologyParts* topologyparts) {
  delete topologyparts_;
  topologyparts_ = topologyparts;
  if (topologyparts) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ddam.Container.topologyParts)
}

// optional .ddam.NetworkHealth networkHealth = 16;
inline bool Container::has_networkhealth() const {
  return !_is_default_instance_ && networkhealth_ != NULL;
}
inline void Container::clear_networkhealth() {
  if (GetArenaNoVirtual() == NULL && networkhealth_ != NULL) delete networkhealth_;
  networkhealth_ = NULL;
}
inline const ::ddam::NetworkHealth& Container::networkhealth() const {
  // @@protoc_insertion_point(field_get:ddam.Container.networkHealth)
  return networkhealth_ != NULL ? *networkhealth_ : *default_instance_->networkhealth_;
}
inline ::ddam::NetworkHealth* Container::mutable_networkhealth() {
  
  if (networkhealth_ == NULL) {
    networkhealth_ = new ::ddam::NetworkHealth;
  }
  // @@protoc_insertion_point(field_mutable:ddam.Container.networkHealth)
  return networkhealth_;
}
inline ::ddam::NetworkHealth* Container::release_networkhealth() {
  
  ::ddam::NetworkHealth* temp = networkhealth_;
  networkhealth_ = NULL;
  return temp;
}
inline void Container::set_allocated_networkhealth(::ddam::NetworkHealth* networkhealth) {
  delete networkhealth_;
  networkhealth_ = networkhealth;
  if (networkhealth) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ddam.Container.networkHealth)
}

// optional .google.protobuf.Timestamp timestamp = 17;
inline bool Container::has_timestamp() const {
  return !_is_default_instance_ && timestamp_ != NULL;
}
inline void Container::clear_timestamp() {
  if (GetArenaNoVirtual() == NULL && timestamp_ != NULL) delete timestamp_;
  timestamp_ = NULL;
}
inline const ::google::protobuf::Timestamp& Container::timestamp() const {
  // @@protoc_insertion_point(field_get:ddam.Container.timestamp)
  return timestamp_ != NULL ? *timestamp_ : *default_instance_->timestamp_;
}
inline ::google::protobuf::Timestamp* Container::mutable_timestamp() {
  
  if (timestamp_ == NULL) {
    timestamp_ = new ::google::protobuf::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:ddam.Container.timestamp)
  return timestamp_;
}
inline ::google::protobuf::Timestamp* Container::release_timestamp() {
  
  ::google::protobuf::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline void Container::set_allocated_timestamp(::google::protobuf::Timestamp* timestamp) {
  delete timestamp_;
  if (timestamp != NULL && timestamp->GetArena() != NULL) {
    ::google::protobuf::Timestamp* new_timestamp = new ::google::protobuf::Timestamp;
    new_timestamp->CopyFrom(*timestamp);
    timestamp = new_timestamp;
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ddam.Container.timestamp)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace ddam

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::ddam::DataType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ddam::DataType>() {
  return ::ddam::DataType_descriptor();
}
template <> struct is_proto_enum< ::ddam::MessageType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ddam::MessageType>() {
  return ::ddam::MessageType_descriptor();
}
template <> struct is_proto_enum< ::ddam::TransportType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ddam::TransportType>() {
  return ::ddam::TransportType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_container_2eproto__INCLUDED
