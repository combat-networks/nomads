// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: traffic.proto

#ifndef PROTOBUF_traffic_2eproto__INCLUDED
#define PROTOBUF_traffic_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/map.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)

namespace ddam {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_traffic_2eproto();
void protobuf_AssignDesc_traffic_2eproto();
void protobuf_ShutdownFile_traffic_2eproto();

class Link;
class LinkStatus;
class Protocol;
class Source;
class Stat;
class Traffic;

// ===================================================================

class LinkStatus : public ::google::protobuf::Message {
 public:
  LinkStatus();
  virtual ~LinkStatus();

  LinkStatus(const LinkStatus& from);

  inline LinkStatus& operator=(const LinkStatus& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LinkStatus& default_instance();

  void Swap(LinkStatus* other);

  // implements Message ----------------------------------------------

  inline LinkStatus* New() const { return New(NULL); }

  LinkStatus* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LinkStatus& from);
  void MergeFrom(const LinkStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LinkStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // optional string projection = 2;
  void clear_projection();
  static const int kProjectionFieldNumber = 2;
  const ::std::string& projection() const;
  void set_projection(const ::std::string& value);
  void set_projection(const char* value);
  void set_projection(const char* value, size_t size);
  ::std::string* mutable_projection();
  ::std::string* release_projection();
  void set_allocated_projection(::std::string* projection);

  // optional double throughput = 3;
  void clear_throughput();
  static const int kThroughputFieldNumber = 3;
  double throughput() const;
  void set_throughput(double value);

  // optional sint32 latency = 4;
  void clear_latency();
  static const int kLatencyFieldNumber = 4;
  ::google::protobuf::int32 latency() const;
  void set_latency(::google::protobuf::int32 value);

  // optional sint32 packetLoss = 5;
  void clear_packetloss();
  static const int kPacketLossFieldNumber = 5;
  ::google::protobuf::int32 packetloss() const;
  void set_packetloss(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ddam.LinkStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr projection_;
  double throughput_;
  ::google::protobuf::int32 latency_;
  ::google::protobuf::int32 packetloss_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_traffic_2eproto();
  friend void protobuf_AssignDesc_traffic_2eproto();
  friend void protobuf_ShutdownFile_traffic_2eproto();

  void InitAsDefaultInstance();
  static LinkStatus* default_instance_;
};
// -------------------------------------------------------------------

class Traffic : public ::google::protobuf::Message {
 public:
  Traffic();
  virtual ~Traffic();

  Traffic(const Traffic& from);

  inline Traffic& operator=(const Traffic& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Traffic& default_instance();

  void Swap(Traffic* other);

  // implements Message ----------------------------------------------

  inline Traffic* New() const { return New(NULL); }

  Traffic* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Traffic& from);
  void MergeFrom(const Traffic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Traffic* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, .ddam.Source> sources = 1;
  int sources_size() const;
  void clear_sources();
  static const int kSourcesFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, ::ddam::Source >&
      sources() const;
  ::google::protobuf::Map< ::std::string, ::ddam::Source >*
      mutable_sources();

  // @@protoc_insertion_point(class_scope:ddam.Traffic)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  typedef ::google::protobuf::internal::MapEntryLite<
      ::std::string, ::ddam::Source,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 >
      Traffic_SourcesEntry;
  ::google::protobuf::internal::MapField<
      ::std::string, ::ddam::Source,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > sources_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_traffic_2eproto();
  friend void protobuf_AssignDesc_traffic_2eproto();
  friend void protobuf_ShutdownFile_traffic_2eproto();

  void InitAsDefaultInstance();
  static Traffic* default_instance_;
};
// -------------------------------------------------------------------

class Source : public ::google::protobuf::Message {
 public:
  Source();
  virtual ~Source();

  Source(const Source& from);

  inline Source& operator=(const Source& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Source& default_instance();

  void Swap(Source* other);

  // implements Message ----------------------------------------------

  inline Source* New() const { return New(NULL); }

  Source* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Source& from);
  void MergeFrom(const Source& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Source* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, .ddam.Link> destinations = 1;
  int destinations_size() const;
  void clear_destinations();
  static const int kDestinationsFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, ::ddam::Link >&
      destinations() const;
  ::google::protobuf::Map< ::std::string, ::ddam::Link >*
      mutable_destinations();

  // optional .google.protobuf.Timestamp timestamp = 2;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  const ::google::protobuf::Timestamp& timestamp() const;
  ::google::protobuf::Timestamp* mutable_timestamp();
  ::google::protobuf::Timestamp* release_timestamp();
  void set_allocated_timestamp(::google::protobuf::Timestamp* timestamp);

  // @@protoc_insertion_point(class_scope:ddam.Source)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  typedef ::google::protobuf::internal::MapEntryLite<
      ::std::string, ::ddam::Link,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 >
      Source_DestinationsEntry;
  ::google::protobuf::internal::MapField<
      ::std::string, ::ddam::Link,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > destinations_;
  ::google::protobuf::Timestamp* timestamp_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_traffic_2eproto();
  friend void protobuf_AssignDesc_traffic_2eproto();
  friend void protobuf_ShutdownFile_traffic_2eproto();

  void InitAsDefaultInstance();
  static Source* default_instance_;
};
// -------------------------------------------------------------------

class Link : public ::google::protobuf::Message {
 public:
  Link();
  virtual ~Link();

  Link(const Link& from);

  inline Link& operator=(const Link& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Link& default_instance();

  void Swap(Link* other);

  // implements Message ----------------------------------------------

  inline Link* New() const { return New(NULL); }

  Link* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Link& from);
  void MergeFrom(const Link& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Link* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // optional .ddam.LinkStatus linkStatus = 1;
  bool has_linkstatus() const;
  void clear_linkstatus();
  static const int kLinkStatusFieldNumber = 1;
  const ::ddam::LinkStatus& linkstatus() const;
  ::ddam::LinkStatus* mutable_linkstatus();
  ::ddam::LinkStatus* release_linkstatus();
  void set_allocated_linkstatus(::ddam::LinkStatus* linkstatus);

  // map<string, .ddam.Protocol> protocols = 2;
  int protocols_size() const;
  void clear_protocols();
  static const int kProtocolsFieldNumber = 2;
  const ::google::protobuf::Map< ::std::string, ::ddam::Protocol >&
      protocols() const;
  ::google::protobuf::Map< ::std::string, ::ddam::Protocol >*
      mutable_protocols();

  // @@protoc_insertion_point(class_scope:ddam.Link)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::ddam::LinkStatus* linkstatus_;
  typedef ::google::protobuf::internal::MapEntryLite<
      ::std::string, ::ddam::Protocol,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 >
      Link_ProtocolsEntry;
  ::google::protobuf::internal::MapField<
      ::std::string, ::ddam::Protocol,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > protocols_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_traffic_2eproto();
  friend void protobuf_AssignDesc_traffic_2eproto();
  friend void protobuf_ShutdownFile_traffic_2eproto();

  void InitAsDefaultInstance();
  static Link* default_instance_;
};
// -------------------------------------------------------------------

class Protocol : public ::google::protobuf::Message {
 public:
  Protocol();
  virtual ~Protocol();

  Protocol(const Protocol& from);

  inline Protocol& operator=(const Protocol& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Protocol& default_instance();

  void Swap(Protocol* other);

  // implements Message ----------------------------------------------

  inline Protocol* New() const { return New(NULL); }

  Protocol* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Protocol& from);
  void MergeFrom(const Protocol& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Protocol* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<uint32, .ddam.Stat> ports = 1;
  int ports_size() const;
  void clear_ports();
  static const int kPortsFieldNumber = 1;
  const ::google::protobuf::Map< ::google::protobuf::uint32, ::ddam::Stat >&
      ports() const;
  ::google::protobuf::Map< ::google::protobuf::uint32, ::ddam::Stat >*
      mutable_ports();

  // @@protoc_insertion_point(class_scope:ddam.Protocol)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  typedef ::google::protobuf::internal::MapEntryLite<
      ::google::protobuf::uint32, ::ddam::Stat,
      ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 >
      Protocol_PortsEntry;
  ::google::protobuf::internal::MapField<
      ::google::protobuf::uint32, ::ddam::Stat,
      ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > ports_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_traffic_2eproto();
  friend void protobuf_AssignDesc_traffic_2eproto();
  friend void protobuf_ShutdownFile_traffic_2eproto();

  void InitAsDefaultInstance();
  static Protocol* default_instance_;
};
// -------------------------------------------------------------------

class Stat : public ::google::protobuf::Message {
 public:
  Stat();
  virtual ~Stat();

  Stat(const Stat& from);

  inline Stat& operator=(const Stat& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Stat& default_instance();

  void Swap(Stat* other);

  // implements Message ----------------------------------------------

  inline Stat* New() const { return New(NULL); }

  Stat* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Stat& from);
  void MergeFrom(const Stat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Stat* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double f = 1;
  void clear_f();
  static const int kFFieldNumber = 1;
  double f() const;
  void set_f(double value);

  // optional double m = 2;
  void clear_m();
  static const int kMFieldNumber = 2;
  double m() const;
  void set_m(double value);

  // @@protoc_insertion_point(class_scope:ddam.Stat)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  double f_;
  double m_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_traffic_2eproto();
  friend void protobuf_AssignDesc_traffic_2eproto();
  friend void protobuf_ShutdownFile_traffic_2eproto();

  void InitAsDefaultInstance();
  static Stat* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// LinkStatus

// optional string type = 1;
inline void LinkStatus::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LinkStatus::type() const {
  // @@protoc_insertion_point(field_get:ddam.LinkStatus.type)
  return type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LinkStatus::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ddam.LinkStatus.type)
}
inline void LinkStatus::set_type(const char* value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ddam.LinkStatus.type)
}
inline void LinkStatus::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ddam.LinkStatus.type)
}
inline ::std::string* LinkStatus::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:ddam.LinkStatus.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LinkStatus::release_type() {
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LinkStatus::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:ddam.LinkStatus.type)
}

// optional string projection = 2;
inline void LinkStatus::clear_projection() {
  projection_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LinkStatus::projection() const {
  // @@protoc_insertion_point(field_get:ddam.LinkStatus.projection)
  return projection_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LinkStatus::set_projection(const ::std::string& value) {
  
  projection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ddam.LinkStatus.projection)
}
inline void LinkStatus::set_projection(const char* value) {
  
  projection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ddam.LinkStatus.projection)
}
inline void LinkStatus::set_projection(const char* value, size_t size) {
  
  projection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ddam.LinkStatus.projection)
}
inline ::std::string* LinkStatus::mutable_projection() {
  
  // @@protoc_insertion_point(field_mutable:ddam.LinkStatus.projection)
  return projection_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LinkStatus::release_projection() {
  
  return projection_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LinkStatus::set_allocated_projection(::std::string* projection) {
  if (projection != NULL) {
    
  } else {
    
  }
  projection_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), projection);
  // @@protoc_insertion_point(field_set_allocated:ddam.LinkStatus.projection)
}

// optional double throughput = 3;
inline void LinkStatus::clear_throughput() {
  throughput_ = 0;
}
inline double LinkStatus::throughput() const {
  // @@protoc_insertion_point(field_get:ddam.LinkStatus.throughput)
  return throughput_;
}
inline void LinkStatus::set_throughput(double value) {
  
  throughput_ = value;
  // @@protoc_insertion_point(field_set:ddam.LinkStatus.throughput)
}

// optional sint32 latency = 4;
inline void LinkStatus::clear_latency() {
  latency_ = 0;
}
inline ::google::protobuf::int32 LinkStatus::latency() const {
  // @@protoc_insertion_point(field_get:ddam.LinkStatus.latency)
  return latency_;
}
inline void LinkStatus::set_latency(::google::protobuf::int32 value) {
  
  latency_ = value;
  // @@protoc_insertion_point(field_set:ddam.LinkStatus.latency)
}

// optional sint32 packetLoss = 5;
inline void LinkStatus::clear_packetloss() {
  packetloss_ = 0;
}
inline ::google::protobuf::int32 LinkStatus::packetloss() const {
  // @@protoc_insertion_point(field_get:ddam.LinkStatus.packetLoss)
  return packetloss_;
}
inline void LinkStatus::set_packetloss(::google::protobuf::int32 value) {
  
  packetloss_ = value;
  // @@protoc_insertion_point(field_set:ddam.LinkStatus.packetLoss)
}

// -------------------------------------------------------------------

// Traffic

// map<string, .ddam.Source> sources = 1;
inline int Traffic::sources_size() const {
  return sources_.size();
}
inline void Traffic::clear_sources() {
  sources_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::ddam::Source >&
Traffic::sources() const {
  // @@protoc_insertion_point(field_map:ddam.Traffic.sources)
  return sources_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::ddam::Source >*
Traffic::mutable_sources() {
  // @@protoc_insertion_point(field_mutable_map:ddam.Traffic.sources)
  return sources_.MutableMap();
}

// -------------------------------------------------------------------

// Source

// map<string, .ddam.Link> destinations = 1;
inline int Source::destinations_size() const {
  return destinations_.size();
}
inline void Source::clear_destinations() {
  destinations_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::ddam::Link >&
Source::destinations() const {
  // @@protoc_insertion_point(field_map:ddam.Source.destinations)
  return destinations_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::ddam::Link >*
Source::mutable_destinations() {
  // @@protoc_insertion_point(field_mutable_map:ddam.Source.destinations)
  return destinations_.MutableMap();
}

// optional .google.protobuf.Timestamp timestamp = 2;
inline bool Source::has_timestamp() const {
  return !_is_default_instance_ && timestamp_ != NULL;
}
inline void Source::clear_timestamp() {
  if (GetArenaNoVirtual() == NULL && timestamp_ != NULL) delete timestamp_;
  timestamp_ = NULL;
}
inline const ::google::protobuf::Timestamp& Source::timestamp() const {
  // @@protoc_insertion_point(field_get:ddam.Source.timestamp)
  return timestamp_ != NULL ? *timestamp_ : *default_instance_->timestamp_;
}
inline ::google::protobuf::Timestamp* Source::mutable_timestamp() {
  
  if (timestamp_ == NULL) {
    timestamp_ = new ::google::protobuf::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:ddam.Source.timestamp)
  return timestamp_;
}
inline ::google::protobuf::Timestamp* Source::release_timestamp() {
  
  ::google::protobuf::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline void Source::set_allocated_timestamp(::google::protobuf::Timestamp* timestamp) {
  delete timestamp_;
  if (timestamp != NULL && timestamp->GetArena() != NULL) {
    ::google::protobuf::Timestamp* new_timestamp = new ::google::protobuf::Timestamp;
    new_timestamp->CopyFrom(*timestamp);
    timestamp = new_timestamp;
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ddam.Source.timestamp)
}

// -------------------------------------------------------------------

// Link

// optional .ddam.LinkStatus linkStatus = 1;
inline bool Link::has_linkstatus() const {
  return !_is_default_instance_ && linkstatus_ != NULL;
}
inline void Link::clear_linkstatus() {
  if (GetArenaNoVirtual() == NULL && linkstatus_ != NULL) delete linkstatus_;
  linkstatus_ = NULL;
}
inline const ::ddam::LinkStatus& Link::linkstatus() const {
  // @@protoc_insertion_point(field_get:ddam.Link.linkStatus)
  return linkstatus_ != NULL ? *linkstatus_ : *default_instance_->linkstatus_;
}
inline ::ddam::LinkStatus* Link::mutable_linkstatus() {
  
  if (linkstatus_ == NULL) {
    linkstatus_ = new ::ddam::LinkStatus;
  }
  // @@protoc_insertion_point(field_mutable:ddam.Link.linkStatus)
  return linkstatus_;
}
inline ::ddam::LinkStatus* Link::release_linkstatus() {
  
  ::ddam::LinkStatus* temp = linkstatus_;
  linkstatus_ = NULL;
  return temp;
}
inline void Link::set_allocated_linkstatus(::ddam::LinkStatus* linkstatus) {
  delete linkstatus_;
  linkstatus_ = linkstatus;
  if (linkstatus) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ddam.Link.linkStatus)
}

// map<string, .ddam.Protocol> protocols = 2;
inline int Link::protocols_size() const {
  return protocols_.size();
}
inline void Link::clear_protocols() {
  protocols_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::ddam::Protocol >&
Link::protocols() const {
  // @@protoc_insertion_point(field_map:ddam.Link.protocols)
  return protocols_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::ddam::Protocol >*
Link::mutable_protocols() {
  // @@protoc_insertion_point(field_mutable_map:ddam.Link.protocols)
  return protocols_.MutableMap();
}

// -------------------------------------------------------------------

// Protocol

// map<uint32, .ddam.Stat> ports = 1;
inline int Protocol::ports_size() const {
  return ports_.size();
}
inline void Protocol::clear_ports() {
  ports_.Clear();
}
inline const ::google::protobuf::Map< ::google::protobuf::uint32, ::ddam::Stat >&
Protocol::ports() const {
  // @@protoc_insertion_point(field_map:ddam.Protocol.ports)
  return ports_.GetMap();
}
inline ::google::protobuf::Map< ::google::protobuf::uint32, ::ddam::Stat >*
Protocol::mutable_ports() {
  // @@protoc_insertion_point(field_mutable_map:ddam.Protocol.ports)
  return ports_.MutableMap();
}

// -------------------------------------------------------------------

// Stat

// optional double f = 1;
inline void Stat::clear_f() {
  f_ = 0;
}
inline double Stat::f() const {
  // @@protoc_insertion_point(field_get:ddam.Stat.f)
  return f_;
}
inline void Stat::set_f(double value) {
  
  f_ = value;
  // @@protoc_insertion_point(field_set:ddam.Stat.f)
}

// optional double m = 2;
inline void Stat::clear_m() {
  m_ = 0;
}
inline double Stat::m() const {
  // @@protoc_insertion_point(field_get:ddam.Stat.m)
  return m_;
}
inline void Stat::set_m(double value) {
  
  m_ = value;
  // @@protoc_insertion_point(field_set:ddam.Stat.m)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ddam

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_traffic_2eproto__INCLUDED
